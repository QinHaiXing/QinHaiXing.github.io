<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx启动前端项目</title>
      <link href="/2024/05/10/day20-Nginx%E5%90%AF%E5%8A%A8%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/05/10/day20-Nginx%E5%90%AF%E5%8A%A8%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx启动前端项目"><a href="#Nginx启动前端项目" class="headerlink" title="Nginx启动前端项目"></a>Nginx启动前端项目</h1><p>Nginx简单来说 就相当于启动前端的服务器  可以理解为java后端对应有一个Tocat 那么前端就有一个Nginx</p><p>那么Nginx如何启动前端项目呢</p><h2 id="Nginx启动命令"><a href="#Nginx启动命令" class="headerlink" title="Nginx启动命令"></a>Nginx启动命令</h2><p>1.进入到nginx文件夹</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405101541072.png" alt="image-20240510154130824"></p><ul><li>注意：路径不能有中文</li></ul><p>2.在路径输入cmd进入控制台</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102247436.png" alt="image-20240510154324596"></p><p>3.输入启动命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx.exe</span><br></pre></td></tr></table></figure><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102247128.png" alt="image-20240510154423163"></p><p>4.在网址输入localhost:8080（默认） 我这里设置是90了</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102247390.png" alt="image-20240510154629884"></p><h2 id="Nginx结束命令"><a href="#Nginx结束命令" class="headerlink" title="Nginx结束命令"></a>Nginx结束命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure><ul><li>注意：如果你启动了前一个nginx项目 你不关掉的话 那么再启动一个nginx项目 还是原来的 除非他们端口号不一样</li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://blog.csdn.net/Tel_17674647975/article/details/126300128?ops_request_misc=%7B%22request_id%22:%22171532650616800225512571%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171532650616800225512571&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-126300128-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=nginx%E5%90%AF%E5%8A%A8&spm=1018.2226.3001.4187">三种启动nginx.exe的方法_nginx启动-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是MVCC</title>
      <link href="/2024/05/09/MySql07-MVCC/"/>
      <url>/2024/05/09/MySql07-MVCC/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h1><ul><li>MVCC指的是<strong>多版本并发控制</strong></li><li>用于<strong>实现事务的并发控制</strong></li><li>它运行<strong>同一个时间</strong> <strong>多个事务</strong> 对<strong>同一个数据集</strong>进行<strong>读写操作</strong></li><li>同时防止数据不一致和其他问题</li></ul><h1 id="MVCC的实现机制"><a href="#MVCC的实现机制" class="headerlink" title="MVCC的实现机制"></a>MVCC的实现机制</h1><h2 id="隐藏字段和undo-log"><a href="#隐藏字段和undo-log" class="headerlink" title="隐藏字段和undo log"></a>隐藏字段和undo log</h2><ul><li>在一行数据中 有两个隐藏字段 一个是版本号 一个是回滚指针  </li><li>多版本链表（Multi-Version List）来存储数据。每个数据⾏都会 有⼀个多版本链表，其中存储着该⾏数据的所有历史版本</li><li>每次修改数据 版本号会自增  回滚指针指向上一个版本数据</li><li>链表头存放最新的数据 链表尾存放的是最早的数据</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405091159369.png" alt="image-20240509114607417"></p><h2 id="当前读和快照度"><a href="#当前读和快照度" class="headerlink" title="当前读和快照度"></a>当前读和快照度</h2><ul><li>当前读：读的时候加锁 这样别的事务无法修改 读到的是最新的数据 但是读写互斥</li><li>快照度：读的时候不加锁 读的是快照版本 可能不是最新的数据 读写不互斥 能够并发执行</li></ul><h2 id="readView读视图"><a href="#readView读视图" class="headerlink" title="readView读视图"></a>readView读视图</h2><h3 id="什么是readView"><a href="#什么是readView" class="headerlink" title="什么是readView?"></a>什么是readView?</h3><p>当事务读取数据时 会生成一个读视图  readView是记录当前未提交事务的id 也是MVCC读取数据的依据</p><p>如图所示：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405091159123.png" alt="image-20240509115901920"></p><h3 id="ReadView属性："><a href="#ReadView属性：" class="headerlink" title="ReadView属性："></a>ReadView属性：</h3><ol><li>未提交事务id</li><li>最小事务id</li><li>最大事务id+1</li><li>当前事务id</li></ol><h2 id="MVCC执行过程"><a href="#MVCC执行过程" class="headerlink" title="MVCC执行过程"></a>MVCC执行过程</h2><p>通过内部定义的一些规则 将多版本链表（Multi-Version List）中的版本号进行比对 最后读到是复合规则的版本号</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405091209834.png" alt="file_1715227737714_457"></p><h3 id="过程（RC级别）："><a href="#过程（RC级别）：" class="headerlink" title="过程（RC级别）："></a>过程（RC级别）：</h3><ol><li><p>在查询时获取读视图</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405091217835.png" alt="image-20240509121030345"></p></li><li><p>将版本号放入规则匹配 从最新的版本开始：</p><ul><li>将4带进去</li><li>4！&#x3D;5</li><li>4！&lt;3</li><li>4！&gt;6</li><li>4在3和6之间 但是4在活跃id集合中{3,4,5}</li><li>结果： 4中的数据不符合</li><li>将3放进去重新匹配</li></ul></li><li><p>经过匹配找到复合的版本数据 最后只有2这个版本复合 所以只能读到2的数据</p></li><li><p>同理 下一个读视图 </p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405091217373.png" alt="image-20240509121741140"></p></li></ol><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405091218861.png" alt="image-20240509121821879"></p><h2 id="RC级别和RR级别"><a href="#RC级别和RR级别" class="headerlink" title="RC级别和RR级别"></a>RC级别和RR级别</h2><ul><li>RC级别：每次查询生成一个读视图</li><li>RR级别：复用第一次查询的读视图</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库主从同步原理</title>
      <link href="/2024/05/09/MySql08-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
      <url>/2024/05/09/MySql08-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库主从同步原理"><a href="#数据库主从同步原理" class="headerlink" title="数据库主从同步原理"></a>数据库主从同步原理</h1><ul><li><p>数据库主从同步原理指的是：将主数据库同步到副数据库的意思</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405091230573.png" alt="image-20240509123024478"></p></li></ul><h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><p>binlog日志：</p><p>binlog日志是MySQL中的一个二进制文件 里面记录了数据库所有的DDL和DML</p><p>具体：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405091240080.png" alt="image-20240509123242187"></p><p>过程：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据，</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简历项目模块可以深挖的点</title>
      <link href="/2024/05/09/day19-%E7%AE%80%E5%8E%86%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8F%AF%E4%BB%A5%E6%B7%B1%E6%8C%96%E7%9A%84%E7%82%B9/"/>
      <url>/2024/05/09/day19-%E7%AE%80%E5%8E%86%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8F%AF%E4%BB%A5%E6%B7%B1%E6%8C%96%E7%9A%84%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="简历项目模块可以深挖的点"><a href="#简历项目模块可以深挖的点" class="headerlink" title="简历项目模块可以深挖的点"></a>简历项目模块可以深挖的点</h1><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102248043.png" alt="image-20240509141830252"></p><p><strong>可以深挖这些模块 参考多个项目相同模块的不同设计 找到他们的不同优缺点</strong></p><p>例如：</p><p>权限认证：</p><ol><li>功能实现<ol><li>业务功能实现<ul><li>账号密码登录</li><li>二维码登录</li><li>手机短信登录</li><li>用户、角色、权限管理和分配</li></ul></li><li>技术方案支持<ul><li>RBAC模型</li><li>Spring Security</li><li>Apeche Shiro</li></ul></li></ol></li><li>常见问题<ul><li>token刷新</li><li>加密和解密</li><li>Xss放跨站攻击</li></ul></li><li><strong>权限系统设计（架构必学）</strong><ul><li>可拓展性</li><li>高可用性</li><li>通用性</li></ul></li></ol><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 编程日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql执行很慢怎么分析</title>
      <link href="/2024/05/08/MySql01-Sql%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90/"/>
      <url>/2024/05/08/MySql01-Sql%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E6%80%8E%E4%B9%88%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Sql执行很慢怎么分析"><a href="#Sql执行很慢怎么分析" class="headerlink" title="Sql执行很慢怎么分析"></a>Sql执行很慢怎么分析</h1><p>使用Mysql自带的分析工具EXPLAIN</p><h3 id><a href="#" class="headerlink" title></a><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102314467.png" alt="image-20240424133633911"></h3><p><strong>可以使用key字段和key_len查看是否命中索引</strong> （主要是验证索引是否失效）</p><p><strong>可以通过type字段 查看是否还有优化空间</strong>（主要是看这个）</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102315192.png" alt="image-20240424133754645"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102315451.png" alt="image-20240424133816607"></p><p>尽量不要让sql语句是all或者index</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发事务问题：脏读、不可重复读、幻读</title>
      <link href="/2024/05/08/MySql05-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%EF%BC%9A%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB/"/>
      <url>/2024/05/08/MySql05-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%EF%BC%9A%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="并发事务问题：脏读、不可重复读、幻读"><a href="#并发事务问题：脏读、不可重复读、幻读" class="headerlink" title="并发事务问题：脏读、不可重复读、幻读"></a>并发事务问题：脏读、不可重复读、幻读</h1><table><thead><tr><th align="left">问题</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">脏读</td><td align="left">一个事务读到另外一个事务还没有提交的数据。</td></tr><tr><td align="left">不可重复读</td><td align="left">一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</td></tr><tr><td align="left">幻读</td><td align="left">一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影”</td></tr></tbody></table><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读:"></a>脏读:</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405081628334.png" alt="image-20240508161022620"></p><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><ol><li>事务A查询id为1的数据</li><li>事务B查询id为1的数据</li><li>事务A更新了id为1的数据</li></ol><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p>事务B读到了事务A还没更新id的数据</p><h2 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405081628660.png" alt="image-20240508161311823"></p><h3 id="过程：-1"><a href="#过程：-1" class="headerlink" title="过程："></a>过程：</h3><ol><li>事务A查询id为1的数据</li><li>事务B更新了id为1的数据</li><li>事务A又查询了id为1的数据（此时查询的是事务B修改了的数据）</li></ol><h3 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h3><p>事务A两次读取的数据不一样</p><h2 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405081628575.png" alt="image-20240508161838495"></p><h3 id="过程：-2"><a href="#过程：-2" class="headerlink" title="过程："></a>过程：</h3><ol><li>事务A查询id为1的数据（此时数据为空）</li><li>事务B添加了一条id为1的数据 并且已经提交</li><li>事务A添加id为1的数据（此时会报错）</li><li>事务A再次查询id为1的数据（由于解决了不可重复读导致两次查询的数据一样——都为空）</li></ol><h3 id="结果：-2"><a href="#结果：-2" class="headerlink" title="结果："></a>结果：</h3><p>由于解决了不可重复读导致两次查询的数据一样——都为空</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405081628124.png" alt="image-20240508162324472"></p><ul><li>注意：事务隔离级别越高 性能越差</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>undo log和redo log的区别</title>
      <link href="/2024/05/08/MySql06-undo%20log%E5%92%8Credo%20log%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/05/08/MySql06-undo%20log%E5%92%8Credo%20log%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="undo-log和redo-log的区别"><a href="#undo-log和redo-log的区别" class="headerlink" title="undo log和redo log的区别"></a>undo log和redo log的区别</h1><p>Undo log”（撤销日志）和 “redo log”（重做日志）是数据库系统中常见的两种日志类型，用于确保数据库的一致性和持久性。它们的主要区别在于它们的作用和用途：</p><ol><li><strong>Undo Log（回滚日志）</strong>：<ul><li>撤销日志记录了事务执行过程中对数据库的修改操作，以便在事务回滚或发生错误时可以将数据库<strong>恢复到之前的状态</strong>。</li><li>撤销日志中记录了<strong>每个事务所做的修改的逆操作</strong>，因此可以用来撤销事务的影响。<strong>（逻辑变化）</strong></li><li>撤销日志通常用于实现数据库的 ACID 特性中的<strong>原子性</strong></li></ul></li><li><strong>Redo Log（重做日志）</strong>：<ul><li>重做日志记录了数据库的每个事务所做的修改操作，以便<strong>在数据库崩溃或意外关闭后可以重做这些修改</strong>，确保数据的完整性和一致性。<strong>（物理变化）</strong></li><li>重做日志中记录了事务对数据库的修改操作，但<strong>记录的是修改的结果而不是具体的操作过程</strong>，因此可以用来重新执行事务的影响。</li><li>重做日志通常用于实现数据库的 ACID 特性中的 <strong>“Durability”（持久性）</strong>，确保即使在数据库<strong>发生故障时</strong>，也能够<strong>恢复数据并保持一致性。</strong></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 运行Java项目</title>
      <link href="/2024/05/08/day18-Linux%20%E8%BF%90%E8%A1%8CJava%E9%A1%B9%E7%9B%AE/"/>
      <url>/2024/05/08/day18-Linux%20%E8%BF%90%E8%A1%8CJava%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-运行Java项目"><a href="#Linux-运行Java项目" class="headerlink" title="Linux 运行Java项目"></a>Linux 运行Java项目</h1><h2 id="1-用Maven把项目打成jar包"><a href="#1-用Maven把项目打成jar包" class="headerlink" title="1.用Maven把项目打成jar包"></a>1.用Maven把项目打成jar包</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405081224732.png" alt="image-20240508115943606"></p><p>jar包：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405081224399.png" alt="image-20240508120025941"></p><h2 id="2-将jar包上传到服务器"><a href="#2-将jar包上传到服务器" class="headerlink" title="2.将jar包上传到服务器"></a>2.将jar包上传到服务器</h2><p>上传：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405081224502.png" alt="image-20240508122306101"></p><p>进入服务器：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405081224394.png" alt="image-20240508122051173"></p><p>输入以下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/java  -jar -Xmx1024M -Xms256M  /www/wwwroot/friend-matching-backend/Friend_Matching-0.0.1-SNAPSHOT.jar --server.port=8080 spring.prpfiles.actice=prod</span><br></pre></td></tr></table></figure><p>成功启动：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405081224071.png" alt="image-20240508122419095"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁的理论</title>
      <link href="/2024/04/30/day10-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E7%90%86%E8%AE%BA/"/>
      <url>/2024/04/30/day10-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis分布式锁的理论"><a href="#Redis分布式锁的理论" class="headerlink" title="Redis分布式锁的理论"></a>Redis分布式锁的理论</h1><p>锁与分布式锁</p><p>首先 什么是锁？  </p><p>锁其实就是  在有限的资源中 控制在同一时间的多个进程 只有其中某些进程能够到访问资源</p><p>Java 实现锁：synchronized 关键字、并发包的类</p><p>问题：只对单个服务器的 JVM 有效</p><p>分布式锁的引用场景</p><p>为啥需要分布式锁？</p><ol><li>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F; 服务器）能访问到资源。</li><li>单个锁只对单个 JVM 有效</li><li>动态分配定时任务给服务器</li></ol><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071622203.png" alt="image-20240408235247047"></p><p>如上图： 服务器A  B C都想执行定时任务  这个时候  我们分配一把锁  让服务器A B C去“抢锁”  谁抢到谁就去执行  当抢到锁的时候 B C无法执行</p><p>（其实可以理解为抢厕所….   三个人想上厕所  谁最先来谁去  上厕所的人把门关了  另外两个人就进不来了）</p><h4 id="抢锁机制"><a href="#抢锁机制" class="headerlink" title="抢锁机制"></a>抢锁机制</h4><p>怎么保证同一时间只有 1 个服务器能抢到锁？</p><p><strong>核心思想</strong> 就是：先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待。</p><p>等先来的人执行方法结束，把标识清空，其他的人继续抢锁。</p><p>实现：</p><p>✔ Redis 实现：内存数据库，<strong>读写速度快</strong> 。支持 <strong>setnx</strong>、lua 脚本，比较方便我们实现分布式锁。</p><p>setnx：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false</p><p>例如 set lock A nx（设置Lock的值为A  表示目前A在”上厕所“  lock原来为空  设置成功 返回True）</p><p>这个时候 set lock B nx (这个时候B想“上厕所” 但是A已经在上了 所以B返回False) </p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>要设置过期时间：</li></ul><p>​比如上面那个例子 lock一直等于A 没有过期时间 那么A执行完任务 但是后面的B无法“上厕所”</p><p>​<strong>所以一定一定要加过期时间</strong></p><ul><li><p>没有执行完 但是到了过期时间怎么办？（相当于你上厕所没上完 厕所门开了 下一个兄弟进来跟你一起上厕所了….）</p><p>​偏书面的说法：服务器A执行时间为40s 锁过期时间为30s 当A执行到30s时 锁被释放 B看到锁被释放 B开始执行</p></li></ul><p>​<strong>解决方法</strong>：续期（相当与你告诉外面的人 你拉屎没拉完  再等等）</p><ul><li>释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最后还是释放了别人的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子操作</span></span><br><span class="line"><span class="keyword">if</span>(get lock == A) &#123;</span><br><span class="line">    <span class="comment">// set lock B</span></span><br><span class="line">    del lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F; 服务器）能访问到资源。</p><p>Java 实现锁：synchronized 关键字、并发包的类</p><p>问题：只对单个 JVM 有效</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>为啥需要分布式锁？</p><ol><li>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F; 服务器）能访问到资源。</li><li>单个锁只对单个 JVM 有效</li></ol><h3 id="分布式锁实现的关键"><a href="#分布式锁实现的关键" class="headerlink" title="分布式锁实现的关键"></a>分布式锁实现的关键</h3><h4 id="抢锁机制-1"><a href="#抢锁机制-1" class="headerlink" title="抢锁机制"></a>抢锁机制</h4><p>怎么保证同一时间只有 1 个服务器能抢到锁？</p><p><strong>核心思想</strong> 就是：先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待。</p><p>等先来的人执行方法结束，把标识清空，其他的人继续抢锁。</p><p>MySQL 数据库：select for update 行级锁（最简单）</p><p>（乐观锁）</p><p>✔ Redis 实现：内存数据库，<strong>读写速度快</strong> 。支持 <strong>setnx</strong>、lua 脚本，比较方便我们实现分布式锁。</p><p>setnx：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>用完锁要释放（腾地方）√</p></li><li><p><strong>锁一定要加过期时间 √</strong></p></li><li><p>如果方法执行时间过长，锁提前过期了？</p><p>问题：</p><ol><li>连锁效应：释放掉别人的锁</li><li>这样还是会存在多个方法同时执行的情况</li></ol></li></ol><p>​解决方案：续期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!end)&#125;&#123;</span><br><span class="line">    续期</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">end = <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最后还是释放了别人的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子操作</span></span><br><span class="line"><span class="keyword">if</span>(get lock == A) &#123;</span><br><span class="line">    <span class="comment">// set lock B</span></span><br><span class="line">    del lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis + lua 脚本实现</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装Redis</title>
      <link href="/2024/04/30/day16-Linux%E4%B8%8B%E5%AE%89%E8%A3%85Redis/"/>
      <url>/2024/04/30/day16-Linux%E4%B8%8B%E5%AE%89%E8%A3%85Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下安装Redis"><a href="#Linux下安装Redis" class="headerlink" title="Linux下安装Redis"></a>Linux下安装Redis</h1><p>1.下载安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-5.0.14.tar.gz</span><br></pre></td></tr></table></figure><p>2.解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf redis-5.0.14.tar.gz -C /usr/local/redis</span><br></pre></td></tr></table></figure><p>3.然后进入到redis目录，进入redis-6.0.5，然后执行make，控制台会输出一编译的信息</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071624809.png" alt="image-20240502000927611"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071624918.png" alt="image-20240502000939608"></p><p>4.安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure><p>5.启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure><p>6.参考：</p><p><a href="https://blog.csdn.net/qq_45784913/article/details/120678054?ops_request_misc=%7B%22request_id%22:%22171457724316800184124504%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171457724316800184124504&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120678054-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=linux%E5%AE%89%E8%A3%85redis&spm=1018.2226.3001.4187">Linux下安装Redis（超详细教程）_linux安装redis-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux permission denied解决方法</title>
      <link href="/2024/04/30/day16-Linux%20permission%20denied%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2024/04/30/day16-Linux%20permission%20denied%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-permission-denied解决方法"><a href="#Linux-permission-denied解决方法" class="headerlink" title="Linux permission denied解决方法"></a>Linux permission denied解决方法</h1><p>其实就是你权限不够 你登录root就可以了</p><p>在命令行中输入su </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure><p>然后输入密码：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071624752.png" alt="image-20240501223408025"></p><p>有root就能权限够了</p><p>如果不记得密码可以重新设置：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071624433.png" alt="image-20240501223524229"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux同时安装JDK8和JDK11</title>
      <link href="/2024/04/30/day17-linux%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85JDK8%E5%92%8CJDK11/"/>
      <url>/2024/04/30/day17-linux%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85JDK8%E5%92%8CJDK11/</url>
      
        <content type="html"><![CDATA[<h1 id="linux同时安装JDK8和JDK11"><a href="#linux同时安装JDK8和JDK11" class="headerlink" title="linux同时安装JDK8和JDK11"></a>linux同时安装JDK8和JDK11</h1><p>1.安装OpenJDK11</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install java-11-openjdk</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.安装JDK8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install java-8-openjdk</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.更改java版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alternatives --config java</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071600530.png" alt="image-20240501223051012"></p><p>输入1或者2选择版本</p><p>4.查看是否生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071600307.png" alt="image-20240501223153627"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存预热</title>
      <link href="/2024/04/30/day9-Redis%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD/"/>
      <url>/2024/04/30/day9-Redis%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis缓存预热："><a href="#Redis缓存预热：" class="headerlink" title="Redis缓存预热："></a>Redis缓存预热：</h1><h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><p>当数据库查询慢 用户访问慢 可以考虑将数据库常用的数据作为缓存 减少数据库负担 增加访问速度</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>减少数据库负担 </li><li>增加访问速度</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>增加开发成本（你要额外的开发、设计）</li><li>预热的时机和时间如果错了，有可能你缓存的数据不对或者太老</li><li>需要占用额外空间</li></ol><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>用定时任务，每天刷新所有用户的推荐列表</p><ol><li>缓存预热的意义（新增少、总用户多）</li><li>缓存的空间不能太大，要预留给其他缓存空间</li><li>缓存数据的周期（此处每天一次）</li></ol><h3 id="定时任务可能会存在的问题"><a href="#定时任务可能会存在的问题" class="headerlink" title="定时任务可能会存在的问题"></a>定时任务可能会存在的问题</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071621845.png" alt="image-20240408234558979"></p><p>存在的问题：</p><ol><li>多台服务器同时开启定时任务 会浪费资源  如果存在1000台服务器同时执行定时任务 可能会“打鸣”</li><li>脏数据  想象一下1000台服务器执行的定时任务是给数据库添加数据  那么会给数据库带来很严重的后果</li></ol><ul><li>主类开启 @EnableScheduling</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqf.friend.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*告诉spring,运行的时候加载读取这个类*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">JdkSerializationRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>给要定时执行的方法添加 @Scheduling 注解，指定 cron 表达式或者执行频率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqf.friend.job;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.qqf.friend.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.qqf.friend.model.User;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> com.qqf.friend.service.UserService;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存预热</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreCacheJob</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Resource</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; mainUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//    @Scheduled(cron = &quot;20 24 17 * * *&quot;)</span></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 1000,fixedDelay = Long.MAX_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doInsertCasheUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1L</span>; i&lt;=<span class="number">1L</span>; i++)&#123;</span><br><span class="line"><span class="comment">//            User user = userMapper.selectById(i);</span></span><br><span class="line">            mainUserList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Scheduled(cron = &quot;22 26 17 * * *&quot;)</span></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 2000,fixedDelay = Long.MAX_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">doCasheRecommentUser</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Long userId : mainUserList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userId==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            QueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">            Page&lt;User&gt; userPage=userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">20</span>),queryWrapper);</span><br><span class="line"></span><br><span class="line">            String redisKey=String.format(<span class="string">&quot;qqf:user:recommend:%s&quot;</span>,userId);</span><br><span class="line">            ValueOperations&lt;String, Object&gt; opsForValue = redisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//写缓存</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                opsForValue.set(redisKey,userPage,<span class="number">1000</span>*<span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                log.error(<span class="string">&quot;redis set key error&quot;</span>,e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><p>这里写入的是Page（User）类的对象</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071621308.png" alt="image-20240408130717297"></p></li></ul><p>用K值获取对象的时候也要用Page<User>类的对象去接受</User></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071621459.png" alt="image-20240408130842995"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁的实现</title>
      <link href="/2024/04/29/day11-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/04/29/day11-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis分布式锁的实现"><a href="#Redis分布式锁的实现" class="headerlink" title="Redis分布式锁的实现"></a>Redis分布式锁的实现</h1><h2 id="1-引入Redisson"><a href="#1-引入Redisson" class="headerlink" title="1.引入Redisson"></a>1.引入Redisson</h2><h3 id="Redisson介绍："><a href="#Redisson介绍：" class="headerlink" title="Redisson介绍："></a>Redisson介绍：</h3><p>redisson是一个用java连接redis的客户端 redisson里面的RList、RMap、RSet 继承了原来java的List、Map、Set的接口 从而可以通过redisson <strong>像操作java一样 操作redis里的数据</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-添加配置类"><a href="#2-添加配置类" class="headerlink" title="2.添加配置类"></a>2.添加配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqf.friend.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redisson 配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span>  RedissonClient <span class="title function_">getRedisson</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置和添加redis数据库地址 以及设置使用的数据库</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        String redisAddress=String.format(<span class="string">&quot;redis://%s:%s&quot;</span>,host,port);</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setAddress(redisAddress)</span><br><span class="line">                .setDatabase(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">doCasheRecommentUser</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;qqf:precachejob:docache:lock&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">//只有一个进程能够获取</span></span><br><span class="line">          <span class="keyword">if</span> (rLock.tryLock(<span class="number">0</span>,<span class="number">10000L</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;get lock... &quot;</span>+Thread.currentThread().getId());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">          log.error(<span class="string">&quot;doCacheRecommendUser error&quot;</span>,e);</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//只能释放自己的锁</span></span><br><span class="line">          <span class="keyword">if</span> (rLock.isHeldByCurrentThread())&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;unlock... &quot;</span>+Thread.currentThread().getId());</span><br><span class="line">              rLock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="4-看门狗机制"><a href="#4-看门狗机制" class="headerlink" title="4.看门狗机制"></a>4.看门狗机制</h2><p>如果执行任务的时间大于锁的释放时间 看门狗会给该任务自动续期</p><p><a href="https://blog.csdn.net/qq_37436172/article/details/130656960?ops_request_misc=%7B%22request_id%22:%22171306750316800182159487%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171306750316800182159487&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130656960-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=Redisson%E7%9C%8B%E9%97%A8%E7%8B%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&spm=1018.2226.3001.4187">Redisson看门狗原理_redis看门狗守护机制原理-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON无法反序列化</title>
      <link href="/2024/04/29/day14-JSON%E6%97%A0%E6%B3%95%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2024/04/29/day14-JSON%E6%97%A0%E6%B3%95%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="JSON无法反序列化"><a href="#JSON无法反序列化" class="headerlink" title="JSON无法反序列化"></a>JSON无法反序列化</h1><h2 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h2><p><strong>JSON parse error: Cannot deserialize value of type</strong></p><h3 id="具体："><a href="#具体：" class="headerlink" title="具体："></a>具体：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message: &quot;JSON parse error: Cannot deserialize value of type `java.util.Date` </span><br><span class="line">from String \&quot;2022-07-13T16:00:00.000Z\&quot;: not a valid representation </span><br><span class="line">(error: Failed to parse Date value &#x27;2022-07-13T16:00:00.000Z&#x27;: Unparseable date: \&quot;2022-07-13T16:00:00.000Z\&quot;); </span><br><span class="line">nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: </span><br><span class="line">Cannot deserialize value of type `java.util.Date` from String \&quot;2022-07-13T16:00:00.000Z\&quot;: </span><br><span class="line">not a valid representation (error: Failed to parse Date value &#x27;2022-07-13T16:00:00.000Z&#x27;:</span><br><span class="line"> Unparseable date: \&quot;2022-07-13T16:00:00.000Z\&quot;)\n at [Source: (PushbackInputStream); line: 1, column: 255]</span><br><span class="line">  (through reference chain: com.lanren312.ClassReq[\&quot;startTime\&quot;])&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决方法：</p><p>在相关字段加上：    <strong>@JsonFormat(locale&#x3D;”zh”, timezone&#x3D;”GMT+8”, pattern&#x3D;”yyyy-MM-dd”)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(locale=&quot;zh&quot;, timezone=&quot;GMT+8&quot;, pattern=&quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date expireTime;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pom打包没有original文件</title>
      <link href="/2024/04/29/day4%20pom%E6%89%93%E5%8C%85%E6%B2%A1%E6%9C%89original%E6%96%87%E4%BB%B6/"/>
      <url>/2024/04/29/day4%20pom%E6%89%93%E5%8C%85%E6%B2%A1%E6%9C%89original%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="pom打包没有original文件"><a href="#pom打包没有original文件" class="headerlink" title="pom打包没有original文件"></a><strong>pom打包没有original文件</strong></h1><h2 id="原因1：pom没有parent"><a href="#原因1：pom没有parent" class="headerlink" title="原因1：pom没有parent"></a><strong>原因1：pom没有parent</strong></h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071614646.png" alt="image-20240326151032972"></p><h2 id="原因2：没有引入以下插件"><a href="#原因2：没有引入以下插件" class="headerlink" title="原因2：没有引入以下插件"></a><strong>原因2：没有引入以下插件</strong></h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071614693.png" alt="image-20240326151126285"></p><h1 id="报错：There-are-test-failures"><a href="#报错：There-are-test-failures" class="headerlink" title="报错：There are test failures."></a>报错：There are test failures.</h1><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071614783.png" alt="image-20240326151231834"></p><h2 id="解决方法：在properties文件中加入以下标签"><a href="#解决方法：在properties文件中加入以下标签" class="headerlink" title="解决方法：在properties文件中加入以下标签"></a>解决方法：在properties文件中加入以下标签</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071614284.png" alt="image-20240326151320097"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义异常类如何消除trace信息 ^-^</title>
      <link href="/2024/04/29/day3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4trace%E4%BF%A1%E6%81%AF/"/>
      <url>/2024/04/29/day3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4trace%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义异常类如何消除trace信息"><a href="#自定义异常类如何消除trace信息" class="headerlink" title="自定义异常类如何消除trace信息"></a>自定义异常类如何消除trace信息</h1><p>当我们自定义java的异常类，需要将报错信息返回给前端 但是通常trace中的报错信息很多 不需要将太多信息返回给前端怎么办</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071609976.png" alt="image-20240322180904395"></p><p>如图：上图中trace记录堆栈的跳转 让报错显得臃肿</p><p><strong>解决方案：</strong></p><p>在自定义异常类中重写fillInStackTrace()方法</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071609656.png" alt="image-20240322181054096"></p><p><strong>成功解决：</strong></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071609338.png" alt="image-20240322181130216"></p><h2 id="ErrorAxiosError-Network-Error-at-XMLHttpRequest-handleError"><a href="#ErrorAxiosError-Network-Error-at-XMLHttpRequest-handleError" class="headerlink" title="ErrorAxiosError: Network Error at XMLHttpRequest.handleError"></a>ErrorAxiosError: Network Error at XMLHttpRequest.handleError</h2><p>因为这是你很可能是你的粗心而导致的报错【因为你对路径出错了】</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071609620.png" alt="image-20240322181749081"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071609765.png" alt="image-20240322181749081"></p><h2 id="前后端跨域"><a href="#前后端跨域" class="headerlink" title="前后端跨域"></a>前后端跨域</h2><p>什么是跨域？</p><p>跨域是指前端后端 端口、协议、不同，但是前端还是请求另一个端口，就会报错。</p><p><strong>解决方法：</strong></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071610783.png" alt="image-20240322182708189"></p><p>在后端Controller层中加入@CrossOrigin(origins &#x3D; {“<a href="http://localhost:5173" })注解">http://localhost:5173&quot;})注解</a></p><p><a href="http://localhost:5173/">http://localhost:5173</a> ：为前端地址</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 后端整合 Swagger + Knife4j 接口文档</title>
      <link href="/2024/04/29/day5-springboot%E6%95%B4%E5%90%88%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3+%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2024/04/29/day5-springboot%E6%95%B4%E5%90%88%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3+%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-后端整合-Swagger-Knife4j-接口文档"><a href="#Java-后端整合-Swagger-Knife4j-接口文档" class="headerlink" title="Java 后端整合 Swagger + Knife4j 接口文档"></a>Java 后端整合 Swagger + Knife4j 接口文档</h1><h2 id="1-添加依赖（pom里面）"><a href="#1-添加依赖（pom里面）" class="headerlink" title="1.添加依赖（pom里面）"></a>1.添加依赖（pom里面）</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-添加配置类"><a href="#2-添加配置类" class="headerlink" title="2.添加配置类"></a>2.添加配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqf.friend.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2WebMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建API应用</span></span><br><span class="line"><span class="comment">     * apiInfo() 增加API相关信息</span></span><br><span class="line"><span class="comment">     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，</span></span><br><span class="line"><span class="comment">     * 本例采用指定扫描的包路径来定义指定要建立API的目录。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(value = &quot;defaultApi2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">defaultApi2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;标准接口&quot;</span>)</span><br><span class="line">                .apiInfo(apiInfo(<span class="string">&quot;伙伴匹配中心&quot;</span>, <span class="string">&quot;1.0&quot;</span>))<span class="comment">//接口文档标题</span></span><br><span class="line">                .useDefaultResponseMessages(<span class="literal">true</span>)</span><br><span class="line">                .forCodeGeneration(<span class="literal">false</span>)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.qqf.friend.controller&quot;</span>))<span class="comment">//你的controller位置</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建该API的基本信息（这些基本信息会展现在文档页面中）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">(String title, String version)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(title)</span><br><span class="line">                .description(<span class="string">&quot;伙伴匹配中心接口文档&quot;</span>)</span><br><span class="line"><span class="comment">//                .termsOfServiceUrl(&quot;https://blog.csdn.net/xqnode&quot;)</span></span><br><span class="line"><span class="comment">//                .contact(new Contact(&quot;xqnode&quot;, &quot;https://blog.csdn.net/xqnode&quot;, &quot;xiaqingweb@163.com&quot;))</span></span><br><span class="line">                .version(version)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-注意springboot版本是否大于等于2-6以上"><a href="#3-注意springboot版本是否大于等于2-6以上" class="headerlink" title="3.注意springboot版本是否大于等于2.6以上"></a>3.注意springboot版本是否大于等于2.6以上</h2><p>如果大于需要加入以下配置（yml）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">      <span class="attr">pathmatch:</span></span><br><span class="line">        <span class="attr">matching-strategy:</span> <span class="string">ant_path_matcher</span></span><br></pre></td></tr></table></figure><h2 id="4-打开"><a href="#4-打开" class="headerlink" title="4.打开"></a>4.打开</h2><p><a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071614935.png" alt="image-20240403002837950"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqf.friend.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 匹配所有路径</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;http://localhost:5173&quot;</span>) <span class="comment">// 允许跨域请求的域名（*表示允许任何域名）</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>) <span class="comment">// 允许跨域请求的HTTP方法</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>) <span class="comment">// 允许跨域请求的HTTP头信息</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>); <span class="comment">// 是否允许发送cookie</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过.allowCredentials(true)让前端识别携带一个“身份证” 让前端知道是当前用户在访问</p><p>同时前端的Axios也要进行配置 withCredentials:true</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  <span class="title class_">MyAxios</span> = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:8080/&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">20000</span>,</span><br><span class="line">    <span class="attr">withCredentials</span>:<span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户登录Session无法共享问题</title>
      <link href="/2024/04/29/day6-springboot%E6%95%B4%E5%90%88redis+redis%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/"/>
      <url>/2024/04/29/day6-springboot%E6%95%B4%E5%90%88redis+redis%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="用户登录Session无法共享问题"><a href="#用户登录Session无法共享问题" class="headerlink" title="用户登录Session无法共享问题"></a>用户登录Session无法共享问题</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>为什么服务器A登录后，请求发到服务器B，不认识该用户？</p><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>用户在A登录，所以session存在了A上 结果请求B时，B没有用户信息，所以不认识</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071616721.png" alt="image-20240403004412190"></p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>共享存储，而不是把数据放到单台服务器的内存中</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071616476.png" alt="image-20240403004442970"></p><h2 id="如何共享存储？"><a href="#如何共享存储？" class="headerlink" title="如何共享存储？"></a>如何共享存储？</h2><ol><li>MySQL </li><li>文件服务器 ceph</li><li>Redis (基于内存的 K&#x2F;V 数据库)</li></ol><p> 此处选择Redis，因为用户信息读取&#x2F;是否登录的判断极其频繁，Redis基于内存，读写性能很高，简单的数据单机 qps 5w-10w</p><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><h3 id="1-安装Redis-安装好redis安装包后，在idea引入依赖，版本与springboot版本一致"><a href="#1-安装Redis-安装好redis安装包后，在idea引入依赖，版本与springboot版本一致" class="headerlink" title="1.安装Redis 安装好redis安装包后，在idea引入依赖，版本与springboot版本一致"></a>1.安装Redis 安装好redis安装包后，在idea引入依赖，版本与springboot版本一致</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--version版本要和springboot一致--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-在application-yml文件中写上配置"><a href="#2-在application-yml文件中写上配置" class="headerlink" title="2.在application.yml文件中写上配置"></a>2.在application.yml文件中写上配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">        <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="3-安装Quick-Redis，测试本地连接，连接成功"><a href="#3-安装Quick-Redis，测试本地连接，连接成功" class="headerlink" title="3.安装Quick Redis，测试本地连接，连接成功"></a>3.安装Quick Redis，测试本地连接，连接成功</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071616717.png" alt="image-20240403005054172"></p><h2 id="自动将-session-存储到-redis"><a href="#自动将-session-存储到-redis" class="headerlink" title="自动将 session 存储到 redis"></a>自动将 session 存储到 redis</h2><h3 id="通过引入-spring-session-和-redis-的整合，使得自动将-session-存储到-redis-中："><a href="#通过引入-spring-session-和-redis-的整合，使得自动将-session-存储到-redis-中：" class="headerlink" title="通过引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中："></a>通过引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="最后-修改yml文件中的配置"><a href="#最后-修改yml文件中的配置" class="headerlink" title="最后 修改yml文件中的配置"></a>最后 修改yml文件中的配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line"> <span class="attr">session:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">86400</span></span><br><span class="line">    <span class="attr">store-type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><p>​    <strong>store-type: 默认为none 表示存在单台服务器</strong>  </p><p>这样就可以实现多台服务器 通过共享session 从而共享用户登录信息</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis K值序列化问题：</title>
      <link href="/2024/04/29/day8-Redis%20K%E5%80%BC%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/"/>
      <url>/2024/04/29/day8-Redis%20K%E5%80%BC%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-K值序列化问题："><a href="#Redis-K值序列化问题：" class="headerlink" title="Redis K值序列化问题："></a>Redis K值序列化问题：</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>java 已经连接上Redis 但是添加数据时 K值会自动添加序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqf.friend.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qqf.friend.model.request.UserLoginRequest;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">        valueOperations.set(<span class="string">&quot;qqfString&quot;</span>,<span class="string">&quot;qqfString&quot;</span>);</span><br><span class="line">        valueOperations.set(<span class="string">&quot;qqfInt&quot;</span>,<span class="number">666</span>);</span><br><span class="line">        valueOperations.set(<span class="string">&quot;qqfDouble&quot;</span>,<span class="number">0.666</span>);</span><br><span class="line">        UserLoginRequest userLoginRequest=<span class="keyword">new</span> <span class="title class_">UserLoginRequest</span>();</span><br><span class="line">        userLoginRequest.setUserAccount(<span class="string">&quot;RedisTest&quot;</span>);</span><br><span class="line">        userLoginRequest.setUserPassword(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">        valueOperations.set(<span class="string">&quot;qqfObj&quot;</span>,userLoginRequest);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071618734.png" alt="image-20240407111741763"></p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p><strong>添加Redis配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqf.friend.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*告诉spring,运行的时候加载读取这个类*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">JdkSerializationRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071618889.png" alt="image-20240407112624240"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java判断对象中属性不为空的字段数量</title>
      <link href="/2024/04/29/day7-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%B1%9E%E6%80%A7%E4%B8%8D%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%AD%97%E6%AE%B5%E6%95%B0%E9%87%8F/"/>
      <url>/2024/04/29/day7-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%B1%9E%E6%80%A7%E4%B8%8D%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%AD%97%E6%AE%B5%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>判断对象中属性不为空的字段数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqf.friend.tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.qqf.friend.comment.ErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.qqf.friend.exception.BusinessException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">AttributesIsEmpty</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断实体类对象的属性的值为否为空（等于  “null” 或 null 或 “”   这三种，均视为空）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 不是空的属性的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">objectFieldIsEmpty</span><span class="params">(Object obj)</span>  &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = obj.getClass();  <span class="comment">//得到类对象</span></span><br><span class="line">        Field[] fs = clazz.getDeclaredFields(); <span class="comment">//得到属性集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span>(Field field:fs)&#123;            <span class="comment">//遍历属性</span></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>); <span class="comment">//设置属性是可以访问的（私有的也可以）</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (field.get(obj) != <span class="literal">null</span> &amp;&amp; field.get(obj) != <span class="string">&quot;&quot;</span> &amp;&amp; !(<span class="string">&quot;null&quot;</span>.equalsIgnoreCase(field.get(obj).toString()))) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) field.getName();</span><br><span class="line">                    list.add(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IllegalAccessException e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.PARAMS_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加 Long 转 json 精度丢失的配置  ^-^</title>
      <link href="/2024/04/29/%E6%B7%BB%E5%8A%A0%20Long%20%E8%BD%AC%20json%20%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/04/29/%E6%B7%BB%E5%8A%A0%20Long%20%E8%BD%AC%20json%20%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="添加-Long-转-json-精度丢失的配置"><a href="#添加-Long-转-json-精度丢失的配置" class="headerlink" title="添加 Long 转 json 精度丢失的配置"></a>添加 Long 转 json 精度丢失的配置</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071608470.png" alt="image-20240414120959779"></p><h2 id="解决方法：添加一个JsonCoufig配置类"><a href="#解决方法：添加一个JsonCoufig配置类" class="headerlink" title="解决方法：添加一个JsonCoufig配置类"></a>解决方法：添加一个JsonCoufig配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.<span class="keyword">module</span>.SimpleModule;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ser.std.ToStringSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.jackson.JsonComponent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;</span><br><span class="line"></span><br><span class="line">@</span><br><span class="line">         JsonComponent</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加 Long 转 json 精度丢失的配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ObjectMapper <span class="title function_">jacksonObjectMapper</span><span class="params">(Jackson2ObjectMapperBuilder builder)</span> &#123;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> builder.createXmlMapper(<span class="literal">false</span>).build();</span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">module</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>();</span><br><span class="line">        <span class="keyword">module</span>.addSerializer(Long.class, ToStringSerializer.instance);</span><br><span class="line">        <span class="keyword">module</span>.addSerializer(Long.TYPE, ToStringSerializer.instance);</span><br><span class="line">        objectMapper.registerModule(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考笔记</title>
      <link href="/2024/04/28/%E8%BD%AF%E8%80%83/"/>
      <url>/2024/04/28/%E8%BD%AF%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="考试须知"><a href="#考试须知" class="headerlink" title="考试须知"></a>考试须知</h1><h2 id="考试项目"><a href="#考试项目" class="headerlink" title="考试项目"></a>考试项目</h2><ul><li>软件设计师</li><li>分数：150分</li><li>及格线：90分</li></ul><h2 id="考试时间"><a href="#考试时间" class="headerlink" title="考试时间"></a>考试时间</h2><ul><li>11月5日<ul><li>基础知识：早上9.00-11.30</li><li>应用技术：下午14.00-16.30</li></ul></li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>选择题（75分）</p><table><thead><tr><th>知识点</th><th>分数</th><th>考试内容</th></tr></thead><tbody><tr><td>软件工程基础知识</td><td>11</td><td>开发模型、设计原则、测试方法、质量特性、CMM、Pert图、风险管理</td></tr><tr><td>面向对象</td><td>12</td><td>面向对象基本概念、面向对象分析与设计、UML、设计模式</td></tr><tr><td>数据结构与算法</td><td>10</td><td>数组、栈、队列、树与二叉树、图、查找与排序、常见算法</td></tr><tr><td>程序设计语言</td><td>6</td><td>文法、有限自动机、正规式、语句的作用、语句的语义、程序的控制结构、函数调用的参数传递、各种程序语言的特点比较</td></tr><tr><td>计算机硬件基础</td><td>6</td><td>浮点数运算、溢出、算术、逻辑运算、计算机体系结构分类、指令系统基础、CISC与RISC、流水线、Cache存储器可靠性分析、校验方法</td></tr><tr><td>操作系统</td><td>6</td><td>进程状态转换图、信号量与PV操作、死锁问题、银行家算法、段页式存储、页面置换算法、磁盘调度、树形文件系统</td></tr><tr><td>数据库系统</td><td>6</td><td>E-R模型、关系代数、元组演算、规范化理论（键、范式、模式分解)、并发控制</td></tr><tr><td>计算机网络</td><td>5</td><td>OSI模型、TCP&#x2F;IP协议族、子网划分、常用的网络命令</td></tr><tr><td>信息安全知识</td><td>3</td><td>加密解密技术、网络安全、计算机病毒</td></tr><tr><td>多媒体基础</td><td>3</td><td>多媒体基本概念、计算声音、图像、视频文件的容量、JPEG、MPEG</td></tr><tr><td>知识产权与标准化</td><td>2</td><td>作品保护时间，侵权判定，知识产权归属、标准的分类、标准代号</td></tr></tbody></table><h2 id="应用技术"><a href="#应用技术" class="headerlink" title="应用技术"></a>应用技术</h2><p>简答题（75分）</p><table><thead><tr><th>题号</th><th>试题类型</th><th>学科知识点</th><th>考查内容</th></tr></thead><tbody><tr><td>试题1</td><td>必答题</td><td>数据流图</td><td>补充数据流图的缺失部分(补充数据流、补充外部实体、补充数据存储），数据流图的改错（包括修正数据流名称、数据流的起点与终点、删除多余数据流），与数据流图相关的概念简答题。</td></tr><tr><td>试题2</td><td>必答题</td><td>数据库设计</td><td>E-R模型、关系模式、主键、外键、SQL语言</td></tr><tr><td>试题3</td><td>必答题</td><td>UML建模</td><td>用例图、类图与对象图、顺序图、活动图、状态图</td></tr><tr><td>试题4</td><td>必答题</td><td>C语言算法</td><td>链表、栈、二叉树、图基本操作的程序实现、动态规划法、分治法、回溯法、递归法、贪心法</td></tr><tr><td>试题5</td><td>选答题</td><td>C++语言程序设计</td><td>C++语法+设计模式</td></tr><tr><td>试题6</td><td>选答题</td><td>Java语言程序设计</td><td>Java语法+设计模式</td></tr></tbody></table><h1 id="计算机组成原理与体系结构基础知识"><a href="#计算机组成原理与体系结构基础知识" class="headerlink" title="计算机组成原理与体系结构基础知识"></a>计算机组成原理与体系结构基础知识</h1><h2 id="数据的表示和校验码"><a href="#数据的表示和校验码" class="headerlink" title="数据的表示和校验码"></a>数据的表示和校验码</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>十进制转n进制</p><ul><li>用短除法，将余数从后往前排</li></ul><p>n进制转十进制</p><ul><li>按权展开求和</li></ul><p>二进制转八进制</p><ul><li>以小数点为分隔符，3位一组，每组转换成对应的八进制符号</li><li>如：11110000010.01101 –&gt; 001 111 000 010 . 011 010 –&gt; 1 7 0 2 . 3 2</li></ul><p>二进制转十六进制</p><ul><li>以小数点为分隔符，4位一组，每组转换成对应的八进制符号</li><li>如：1111000010.01101 –&gt; 0011 1100 0010 . 0110 1000 –&gt; 3 C 2 . 6 8</li></ul><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>定点数： 小数点的位置固定</p><p>无符号数</p><ul><li>没有符号位，只有数值位。通常只有无符号整数，而没有无符号小数</li></ul><p>有符号数</p><ul><li>有符号位，0表示+，1表示-</li><li>原码<ul><li>如：X&#x3D;+19D，【X】原&#x3D;0，0010011，即00010011</li><li>如：X&#x3D;-19D，【X】原&#x3D;1，0010011，即10010011</li><li>说明：D表示十进制，O表示八进制，B表示二进制，H表示16进制，如不说明则默认为10进制</li></ul></li><li>反码<ul><li>正数的反码与原码相同。如：【+19】反&#x3D;0，0010011</li><li>负数的反码，将数值位全部取反。如：【-19】反&#x3D;1，1101100</li></ul></li><li>补码<ul><li>正数的补码与源码相同。如：【+19】补&#x3D;0，0010011</li><li>负数的补码&#x3D;反码末位+1。如：【-19】补&#x3D;1，1101101</li><li>注意：补码的真值0只有1种表示形式！【+0】补&#x3D;【-0】补&#x3D;00000000</li><li>补码的补码就是原码 </li><li>用补 码来运算数据，可以简化计算机运算部件的设计</li></ul></li><li>移码<ul><li>将补码的符号位取反，移码只能用来表示整数</li></ul></li></ul><p>当机械字长为n时，定点数的补码和移码可表示2^n个数，而其原码和反码只能表示2^n-1个数</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数： 小数点的位置不固定</p><ul><li><p>$$<br>浮点数通常表示成:N&#x3D;R^E·F，如10^5·0.5312<br>$$</p></li><li><p>F称为尾数，R称为基数，E称为阶码</p></li><li><p>阶码E，决定浮点数所能表示的数值范围，它是一个带符号的纯整数，在上面例子中E&#x3D;5</p></li><li><p>尾数F，决定浮点数所能表示的数值精度，它是一个带符号的纯小数，在上面例子中M&#x3D;4</p></li><li><p>在计算浮点数时，要先对阶，且应该是小阶向大阶对</p></li><li><p>规格化要将尾数的绝对值限定在区间【0.5，1】或【0.5，1）</p></li><li><p>最小负数的阶数一定是奇数 ；最大正数第一个2的阶一定是偶数，第二个2的阶数一定是奇数。简称：奇偶奇</p></li></ul><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><ul><li><p>在数据为之间插入k个校验码，通过扩大码距来实现检错和纠错。</p></li><li><p>码距&gt;&#x3D;3</p></li><li><p>$$<br>设数据位是n位．校验位是k位，则n和k必须满足以下关系:2^k-1&gt;&#x3D;n+k<br>$$</p></li></ul><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ul><li>码距等于2，只能检错，不能纠错</li><li>只能检测奇数位出错的编码</li></ul><h3 id="循环冗余码"><a href="#循环冗余码" class="headerlink" title="循环冗余码"></a>循环冗余码</h3><ul><li>码距等于2，只能检错，不能纠错</li><li>k个数据位后产生r个校验位</li><li>在求CRC编码时，采用的是模运算</li></ul><h2 id="计算机体系结构和指令系统"><a href="#计算机体系结构和指令系统" class="headerlink" title="计算机体系结构和指令系统"></a>计算机体系结构和指令系统</h2><h3 id="冯·诺依曼计算机"><a href="#冯·诺依曼计算机" class="headerlink" title="冯·诺依曼计算机"></a>冯·诺依曼计算机</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>计算机由五大部件组成</p><ul><li>输入设备、运算器、存储器、控制器、输出设备</li><li>CPU：由运算器和控制器组成</li><li>主存和辅存：都是指存储器，主存是运行内存，辅存是存储容量</li><li>主机：由CPU和主存</li><li>IO设备：由辅存和输入输出设备组成</li><li>主机和io设备统称硬件</li></ul></li><li><p>指令和数据以同等地位存于存储器，可按地址寻访 </p></li><li><p>指令和数据用二进制表示</p></li><li><p>指令由操作码和地址码组成</p></li><li><p>存储程序</p></li><li><p>以运算器为中心</p><ul><li>输入输出设备与存储器之间的数据传送通过运算器完成</li></ul></li></ul><h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><p>存放数据和程序</p><ul><li>由存储体、MAR、MDR组成</li><li>存储体<ul><li>存储单元：每个存储单元存放一串二进制代码。</li><li>存储字(word)：存储单元中二进制代码的组合。</li><li>存储字长：存储单元中二进制代码的位数。</li><li>存储元：即存储二进制的电子元件，每个存储元可存1bit。</li></ul></li><li>MAR：地址存储器<ul><li>可以用来判断存储单元的个数，如：当MAR&#x3D;4位时，总共有2^4个存储单元</li></ul></li><li>MDR：数据存储器<ul><li>表明了每个存储单元存放的位数，如：当MDR&#x3D;16位时，每个存储单元可以存放16bit</li></ul></li><li>计算机中的大小关系<ul><li>位（比特）：1bit&#x3D;1b</li><li>字节：1Byte&#x3D;1B&#x3D;8byte</li><li>KB：1KB&#x3D;1024B，K&#x3D;2^10</li><li>MB：1MB&#x3D;1024KB ，M&#x3D;2^20</li><li>GB：1GB&#x3D;1024MB，G&#x3D;2^30</li><li>TB：1TB&#x3D;1024GB </li><li>最小的数据单位是位：b</li><li>最小的存储单位是字节：byte</li></ul></li></ul><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>实习算术运算和逻辑运算</p><ul><li><strong>AC:累加器</strong>，用于存放操作数并暂存运算结果。</li><li><strong>ALU:算术逻辑单元</strong>，通过内部复杂的电路实现算数运算、逻辑运算。</li><li>DR:数据缓存寄存器。</li><li>PSW:状态条件寄存器，用来保存指令运行标志。</li></ul><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>指挥各部件，处理异常，使程序得以运行</p><ul><li><p><strong>PC:程序计数器</strong>，也称指令计数器，PC的内容是程序第一条<strong>指令的地址</strong>，并存放下一条指令地址，有自动加1功能。</p></li><li><p>IR:指令寄存器，当CPU执行一条指令时，先把它从内存储器取到缓冲寄存器中，再送入IR暂存。指令寄存器对用户是完全透明的</p></li><li><p>AR:地址寄存器，保存当前CPU所访问的<strong>内存单元地址</strong>。</p></li><li><p>ID:指令译码器，对操作码进行分析。</p></li></ul><p>完成一条指令需要：取指令-分析指令-执行指令</p><h4 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h4><p>将信息转换为机器能识别的形式</p><h4 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h4><p>将结果转换为人们熟知的形式</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>地址码是操作数的地址。</li><li>在指令周期的过程中，指令先从程序计数器PC中获取指令的地址，以便让内存把指令读取到缓冲寄存器DR上，再把指令送入到指令寄存器IR中暂存。</li></ul><h4 id="Flynn分类法"><a href="#Flynn分类法" class="headerlink" title="Flynn分类法"></a>Flynn分类法</h4><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/2024/04/28/%E8%BD%AF%E8%80%83/Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230919160913094.png" alt="image-20230919160913094"></p><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><ul><li>一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。</li><li>指令(又称机器指令):是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。</li></ul><p>指令格式</p><ul><li>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。</li><li>一条指令通常要包括操作码字段 和地址码字段两部分<ul><li>操作码：干什么</li><li>地址码：对谁操作</li></ul></li></ul><h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><ul><li>指令寻址：下一条欲执行指令的指令地址（始终由程序计数器(PC) 给出）</li><li>数据寻址：确定本条指令的地址码指明的真实地址<ul><li>立即寻址。操作数就包含在指令中。</li><li>寄存器寻址。操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名。</li><li>直接寻址。操作数存放在内存单元中，指令中直接给出操作数所在存储单元的地址。</li><li>寄存器间接寻址。操作数存放在内存单元中，操作数所在存储单元的地址在某个寄存器中。</li><li>间接寻址。指令中给出操作数地址的地址。</li><li>相对寻址。指令地址码给出的是一个偏移量（可正可负)，操作数地址等于本条指令的地址加上该偏移量。</li><li>变址寻址。操作数地址等于变址寄存器的内容加偏移量。</li></ul></li></ul><h4 id="CISI和RISI"><a href="#CISI和RISI" class="headerlink" title="CISI和RISI"></a>CISI和RISI</h4><table><thead><tr><th></th><th>RISC（精简指令集计算机）</th><th>CISI（复杂指令集计算机）</th></tr></thead><tbody><tr><td>指令种类</td><td>少</td><td>多</td></tr><tr><td>指令复杂度</td><td>简单</td><td>复杂</td></tr><tr><td>指令长度</td><td>固定</td><td>不固定</td></tr><tr><td>寻址方式</td><td>少</td><td>多</td></tr><tr><td>实现(译码)方式</td><td>硬布线控制逻辑 （组合逻辑控制器）</td><td>微程序控制技术</td></tr><tr><td>通用寄存器数量</td><td>多</td><td>一般</td></tr><tr><td>流水线技术</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="指令的流水处理"><a href="#指令的流水处理" class="headerlink" title="指令的流水处理"></a>指令的流水处理</h4><ul><li>指令控制方式有顺序方式、重叠方式和流水方式三种。</li><li>流水方式：是指并行性或并发性嵌入计算机系统里的一种形式，它把重复的顺序处理过程分解为若干子过程，每个子过程能在专用的独立模块上有效地并发工作。<ul><li>流水线周期为执行时间最长的一段</li><li>流水线计算公式：1条指令执行时间+（指令条数-1）*流水线周期</li><li>流水线的吞吐率：TP&#x3D;指令条数&#x2F;流水线执行时间</li><li>建立时间：To&#x3D;m*to（流水线开始工作后，须经过—定时间才能达到最大吞吐率，这就是建立时间。若m个子过程所用时间一样，均为△to，则建立时间To&#x3D;m x △to）</li><li>流水线的加速比：S&#x3D;不使用流水线执行时间&#x2F;使用流水线执行时间</li></ul></li><li>如问题：例:若指令流水线把一条指令分为取指、分析和执行三部分,且三部分的时间分别是取指2ns ,分析2ns ,执行1ns。那么,流水线周期是多少?100条指令全部执行完毕需要的时间是多少?流水线吞吐率为多少？流水线加速比是多少？<ul><li>流水线周期是：2ns</li><li>100条指令全部执行完毕需要的时间是：5+99*2&#x3D;203ns</li><li>流水线吞吐率：TP&#x3D;100&#x2F;203</li><li>流水线加速比：S&#x3D;500&#x2F;203</li></ul></li></ul><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>  <img src="/2024/04/28/%E8%BD%AF%E8%80%83/Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230919192709092.png" alt="image-20230919192709092"></p><p>层次结构</p><ul><li>主存—辅存:实现虚拟存储系统，解决了主存容量不够的问题。</li><li>Cache—主存:解决了主存与CPU速度不匹配的问题.</li></ul><p>存储器的分类</p><ul><li><p>按位置分类，可分为内存和外存。</p><ul><li>内存(主存)：用来存储当前运行所需要的程序和数据，速度快，容量小。</li><li>外存(辅存)：用来存储当前不参与运行的数据，容量大但速度慢。</li></ul></li><li><p>按材料分类，可分为磁存储器、半导体存储器和光存储器。</p><ul><li>磁存储器：用磁性介质做成，如磁芯、磁泡、磁盘、磁带等。</li><li>半导体存储器：根据所用元件又可分为双极型和MOS型两类;根据是否需要刷新又可分为静态和动态两类。</li><li>光存储器：由光学、电学和机械部件等组成，如光盘存储器。</li></ul></li><li><p>按工作方式，可分为读&#x2F;写存储器和只读存储器。</p><ul><li>读&#x2F;写存储器(RAM)：它指既能读取数据也能存入数据的存储器。</li><li>只读存储器(ROM)：工作过程中仅能读取的存储器。</li></ul></li><li><p>按访问方式分类</p><ul><li>按地址访问</li><li>按内容访问（相联存储器）</li></ul></li><li><p>按寻址方式分类</p><ul><li>随机存储器RAM</li><li>顺序存储器SAM</li><li>直接存储器DAM</li></ul></li></ul><p>其他</p><ul><li>Cache：SRAM（静态随机存储器）</li><li>主存储器：DRAM（动态随机存储器），周期性地刷新</li><li>内存也称主存，外存也称辅存</li></ul><h4 id="高速缓存Cache"><a href="#高速缓存Cache" class="headerlink" title="高速缓存Cache"></a>高速缓存Cache</h4><p>在计算机的存储系统体系中，Cache是访问速度最快的层次。使用Cache改善系统性能的依据是程序的局部性原理。基于局部性原理，不难想到，可以把CPU目前访问的地址“周围”的部分数据放到Cache中，以提高访问效率。它对程序员来说是透明的</p><ul><li>空间局部性:在最近的未来要用到的信息(指令和数据)，很可能与现在正在使用的信息在存储空间上是邻近的。<ul><li>Eg:数组元素、顺序执行的指令代码。</li></ul></li><li>时间局部性:在最近的未来要用到的信息，很可能是现在正在使用的信息。<ul><li>Eg:循环结构里面的指令代码。</li></ul></li></ul><p>要把主存种的地址映射为Cache存储器里面的地址，地址映像方法有三种(由硬件自动完成Cache 与主存之间的地址映射)</p><ul><li>直接映像：就是主存的块与Cache中块的对应关系是固定的。冲突最多<ul><li>优点是，地址变换很简单</li><li>缺点是，灵活性差。</li></ul></li><li>全相联映像：允许主存的任一块可以调入Cache的任一块的空间。冲突最少<ul><li>优点是，主存的块调入Cache的位置不受限制，十分灵活。</li><li>缺点是，无法从主存块号中直接获得Cache的块号，变换比较复杂，速度比较慢。</li></ul></li><li>组相联映像：这种方式是前面两种方式的折中。具体方法是将Cache先分成组再分块。组相联映像就是组间采用直接映像方式，而组内的块采用全相联映像方式。冲突较多</li></ul><p>选择替换算法的目标是使Cache获得最高的命中率。常用的替换算法有以下几种</p><ul><li>随机替换(RAND)算法：用随机数发生器产生一个要替换的块号，将该块替换出去。</li><li>先进先出(FIFO)算法：将最先进入的Cache信息块替换出去。<br>修</li><li>近期最少使用(LRU)算法：将近期最少使用的Cache中的信息块替换出去。这种算<br>法较先进先出算法要好些，但此法也不能保证过去不常用的将来也不常用。</li><li>优化替换(OPT)算法：先执行一次程序，统计Cache的替换情况。有了这样的先验信息，在第二次执行该程序时便可以用最有效的方式来替换，达到最优目的。</li></ul><p>Cache的性能分析</p><ul><li><p>若H为Cache的命中率，t.为Cache的存取时间，tm为主存的访问时间，则Cache 的等效访问时间ta为<br>  $$<br>  t_a&#x3D;Ht_c+(1-H)t_m<br>  $$</p></li><li><p>使用Cache比不使用Cache的CPU访问存储器的速度提高的倍数r可以用下式求得<br>$$<br>r&#x3D;t_m&#x2F;t_a<br>$$</p></li></ul><h4 id="硬盘（磁盘）"><a href="#硬盘（磁盘）" class="headerlink" title="硬盘（磁盘）"></a>硬盘（磁盘）</h4><ul><li>存取时间&#x3D;寻道时间＋等待时间(平均定位时间+转动延迟)<ul><li>寻道时间是指磁头移动到磁道所需的时间;</li><li>等待时间为等待读写的扇区转到磁头下方所用的时间。</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul><li>中断向量提供中断服务程序的入口地址</li><li>中断响应时间：发出中断请求开始到进入中断服务程序</li><li>保存现场：返回来执行原程序，用堆栈来实现</li></ul><h3 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h3><ul><li>系统总线：系统总线是计算机系统内各功能部件(CPU、主存、I&#x2F;O接口）之间相互连接的总线。</li><li>按系统总线传输信息内容的不同，又可分为3类，<strong>数据总线、地址总线和控制总线</strong>。<ul><li>字长决定数据总线的宽度</li><li>容量决定地址总线的宽度</li></ul></li><li>总线结构可以减少信息传输线的数量</li><li>片内总线：片内总线是芯片内部的总线。它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。</li><li>总线带宽&#x3D;每个时钟周期传输的数据位数*时钟频率，算完把单位化成题目要求的就行了</li></ul><h3 id="输入输出技术"><a href="#输入输出技术" class="headerlink" title="输入输出技术"></a>输入输出技术</h3><p>输入输出的控制方式</p><ul><li><p>程序查询方式：指在完成数据的输入&#x2F;输出中，整个输入&#x2F;输出过程是在CPU执行程序的控制下完成的。</p><ul><li>无条件传送方式：无条件地与CPU交换数据。</li><li>程序查询方式：先通过CPU查询外设状态，准备好之后再与CPU交换数据。</li><li>一次只能读写一个字</li><li>由CPU将数放入内存</li><li>CPU和I&#x2F;O只能串行工作</li></ul></li><li><p>中断驱动方式</p><ul><li>CPU和I&#x2F;O可并行工作</li><li>CPU利用率得到提高</li><li>一次只能读写一个字</li><li>由CPU将数放入内存</li><li>I&#x2F;O设备通过中断信号主动报告I&#x2F;O操作已完成</li></ul></li><li><p>直接存储器方式DMA：在存储器与I&#x2F;O设备间直接传送数据，即在内存与I&#x2F;O设备之间传送一个数据块的过程中，不需要CPU的任何干涉，是—种完全由DMA硬件完成I&#x2F;O操作的方式。</p><ul><li>CPU和I&#x2F;0（外设)可并行工作</li><li>仅在传送数据块的开始和结束时才需要CPU的干预</li><li>由外设直接将数据放入内存</li><li>一次读写的单位为“块”而不是字</li></ul></li></ul><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>  计算机系统的可靠性是指从它开始运行(t&#x3D;O)到某个时刻t这段时间内能正常运行的概率，用R(t)表示。</p><ul><li>串联部件的可靠度&#x3D;各部件的可靠度的乘积</li><li>并联部件的可靠度&#x3D;1-部件失效率的乘积。</li><li>部件的失效率&#x3D;1-部件的可靠度</li></ul><p><img src="/2024/04/28/%E8%BD%AF%E8%80%83/Users\86176\AppData\Roaming\Typora\typora-user-images\image-20230919203518668.png" alt="image-20230919203518668"></p><h3 id="加密技术与认证技术"><a href="#加密技术与认证技术" class="headerlink" title="加密技术与认证技术"></a>加密技术与认证技术</h3><p>对称加密和非对称加密</p><ul><li><p>对称加密（私有密钥加密）</p><ul><li>加密和解密是同一把密钥，只有一把密钥</li><li>缺点：密钥分发有缺陷</li><li>优点：加密解密速度很快，适合大量明文数据</li><li>加密算法：DES、3DES、RC-5、IDEA、AES、RC4</li></ul></li><li><p>非对称加密（公开密钥加密）</p><ul><li>加密和解密不是同一把密钥，一共有两把密钥，分别是公钥和私钥</li><li>公钥是共有的，私钥是独有的</li><li>用公钥加密只能用私钥解密，用私钥加密只能用公钥解密</li><li>应该用接收方的公钥加密</li><li>缺点：速度慢</li><li>优点：可以实现防窃听的效果</li><li>加密算法：RSA、ECC、DSA</li></ul></li><li><p>混合加密</p><ul><li>对明文进行对称加密</li><li>将对称加密密钥进行非对称加密</li></ul></li></ul><p>认证技术</p><ul><li><p>摘要</p><ul><li>将发送的明文进行Hash算法后得到摘要放在密文后一起发送过去，与接收方解密后的明文进行相同的Hash算法得到的摘要进行对比如果一致，则没有篡改，否则有篡改</li><li>加密算法：HASH、MD5</li></ul></li><li><p>数字签名</p><ul><li>发送方用自己的私钥对摘要进行签名（加密）得到数字签名放在密文后一起发送过去</li></ul></li><li><p>数字证书</p><ul><li>用户向CA机构申请数字证书将个人信息和公钥发给CA机构CA机构颁给用户数字证书，数字证书用CA的私钥进行签名（加密)用CA的公钥验证（解密）数字证书得到用户的公钥</li></ul></li></ul><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul><li>与（AND）<ul><li>全一为一，有零为零</li></ul></li><li>或（OR）<ul><li>全零为零，有一为一</li></ul></li><li>非（NOT）<ul><li>一变零，零变一</li></ul></li><li>异或（XOR）<ul><li>相异为一，相同为零</li></ul></li><li>同或（XNOR）<ul><li>相同为一，相异为零</li></ul></li><li>与非（NAND）</li><li>先与后非</li><li>或非（NOR）<ul><li>先或后非</li></ul></li></ul><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><ul><li>主动攻击：重放、IP地址欺骗、拒绝服务、系统干涉、修改数据命令</li><li>被动攻击：流量分析、会话拦截</li><li></li></ul><h1 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h1><h2 id="编译程序和解释程序"><a href="#编译程序和解释程序" class="headerlink" title="编译程序和解释程序"></a>编译程序和解释程序</h2><p> 机械语言和汇编语言为低级语言</p><ul><li>机械语言：只能识别0和1的机械指令序列</li><li>汇编语言：汇编指令的集合，汇编指令用符号表示</li></ul><p>高级语言</p><ul><li>JAVA、C、Python、C++、PHP等</li><li>高级语言需要翻译才能让计算机理解</li><li>翻译的方式：汇编、解释、编译</li></ul><p>编译程序和解释程序</p><ul><li>编译器和解释器都不可省略词法分析、语法分析、语义分析且顺序不可交换</li></ul><p>解释程序</p><ul><li>如python</li><li>翻译源程序时不生成独立的目标程序</li><li>解释程序和源程序要参与到程序的运行过程中</li><li>解释方式:词法分析、语法分析、语义分析</li></ul><p>编译程序</p><ul><li>如java</li><li>翻译时将源程序翻译成独立保存的目标程序</li><li>机器上运行的是与源程序等价的目标程序，</li><li>源程序和编译程序都不再参与目标程序的运行过程</li><li>编译方式:词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成<ul><li>词法分析<ul><li>输入：源程序</li><li>输出：记号流</li><li>词法分析阶段的主要作用是：分析构成程序的字符及由字符按照构造规则构成的符号是否符合程序语言的规定</li></ul></li><li>语法分析<ul><li>输入：记号流</li><li>输出：语法树（分析树）</li><li>语法分析阶段的主要作用是：对各条<strong>语句的结构</strong>进行合法性分析，分析程序中的句子结构是否正确</li></ul></li><li>语义分析<ul><li>输入：语法树（分析树）</li><li>语义分析阶段的主要作用是：<ul><li>进行<strong>类型分析和检查</strong></li><li>语法分析阶段可以发现程序中的所有语法错误</li><li>语义分析阶段不能发现程序中所有的语义错误</li><li>语义分析阶段可以发现静态语义错误</li><li>不能发现动态语义错误，动态语义错误运行时才能发现</li></ul></li></ul></li><li>中间代码生成<ul><li>常见的中间代码有：后缀式、三地址码、三元式、四元式和树（图）等形式。</li><li>中间代码可以跨平台</li><li>中间代码与具体的机器无关</li><li>有利于进行与机器无关的优化处理和提高编译程序的可移植性</li></ul></li><li>目标代码生成<ul><li>目标代码生成阶段的工作与具体的机器密切相关</li><li>寄存器的分配处于目标代码生成阶段</li></ul></li></ul></li><li>编译器方式中中间代码生成和代码优化不是必要，可省略。</li></ul><p>符号表</p><ul><li>不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入符号表中。</li><li>记录源程序中各个字符的必要信息，以辅助语义的正确性检查和代码生成。</li></ul><h2 id="传值调用和地址调用"><a href="#传值调用和地址调用" class="headerlink" title="传值调用和地址调用"></a>传值调用和地址调用</h2><p>传值调用</p><ul><li>将实参的值传递给形参，实参可以是变量、常量和表达式。</li><li>不可以实现形参和实参间双向传递数据的效果</li></ul><p>地址调用</p><ul><li>将实参的地址传递给形参，形参必须有地址，实参不能是常量（值），表达式。</li><li>可以实现形参和实参间双向传递数据的效果，即改变形参的值同时也改变了实参的值。</li></ul><h2 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h2><table><thead><tr><th>正规式</th><th>正规集</th></tr></thead><tbody><tr><td>Ab</td><td>字符串ab构成的集合</td></tr><tr><td>a|b</td><td>字符串a、b构成的集合</td></tr><tr><td>a*</td><td>由0个或多个a构成的字符串集合</td></tr><tr><td>(a|b)*</td><td>所有字符a和b构成的串的集合</td></tr><tr><td>a(a|b)*</td><td>以a为首字符的a、b字符串的集合</td></tr><tr><td>(a|b)*abb</td><td>以abb 结尾的a、b字符串的集合</td></tr></tbody></table><h2 id="有限自动化"><a href="#有限自动化" class="headerlink" title="有限自动化"></a>有限自动化</h2><ul><li>有限自动化是词法分析的一个工具，它能够正确地识别正规集</li><li>初态是一个圈，终态是两个圈，有限自动机识别后最终的位置应该在终态</li><li>确定的有限自动机（DFA）：对每一个状态来说识别字符后转移的状态是唯一的</li><li>不确定的有限自动机（NFA）：对每一个状态来说识别字符后转移的状态是不确定的</li></ul><h2 id="上下文无关文法CFG"><a href="#上下文无关文法CFG" class="headerlink" title="上下文无关文法CFG"></a>上下文无关文法CFG</h2><ul><li>上下文无关文法被广泛地用于表示各种程序设计语言的语法规则</li><li>终结符号集：不能继续往下推的</li><li>产生式：包含非终结符号</li></ul><h2 id="中缀、后缀表达式"><a href="#中缀、后缀表达式" class="headerlink" title="中缀、后缀表达式"></a>中缀、后缀表达式</h2><ul><li><p>中缀：a  ？b</p></li><li><p>后缀（逆波兰）：ab？</p></li><li><p>优先级：（）&gt; 乘除 &gt; 加减。</p></li><li><p>中缀转后缀：正常转</p><ul><li>如：1-2*(3+4)&#x2F;5 &#x3D;&#x3D; 1234+ * 5 &#x2F;  -</li></ul></li><li><p>后缀转中缀：从左到右，用栈的方式转，先进后出,先进的出之后放在b的位置</p><ul><li>如：1234+ * 5 &#x2F;  -  - &#x3D;&#x3D;1-2*(3+4)&#x2F;5</li></ul></li></ul><h2 id="语法树中、后序遍历"><a href="#语法树中、后序遍历" class="headerlink" title="语法树中、后序遍历"></a>语法树中、后序遍历</h2><ul><li>中序：左中右<ul><li>中序遍历 得到 中缀式</li></ul></li><li>后序：左右中   <ul><li>后序遍历 得到 后缀式</li></ul></li></ul><h2 id="杂知识点"><a href="#杂知识点" class="headerlink" title="杂知识点"></a>杂知识点</h2><ul><li><p>编译是将高级语言源程序翻译成机器语言程序（汇编形式或机器代码形式)，反编译是编译的逆过程。反编译通常不能把可执行文件还原成高级语言源代码，只能转换成功能上等价的汇编程序。</p></li><li><p>脚本语言都是动态语言（弱类型语言），动态语言都是解释型语言，其程序结构可以在运行中改变，不产生独立保存的目标程序。如：python、php、js、</p></li><li><p>静态语言其所有成分可在编译时确定。如：C、C++</p></li><li><p>C或C++中的指针变量可以是全局的也可以是局部的</p></li><li><p>Lisp是函数式编程语言，Prolog是逻辑式程序语言</p></li><li><p>编译过程中为变量分配存储单元所用的地址是逻辑地址，程序运行时再映射为物理地址。</p></li><li><p>程序运行时的用户内存空间一般划分为代码区、静态数据区、栈区和堆区，其中栈区和堆区也称为动态数据区。全局变量的存储空间在静态数据区。</p></li><li><p>递归下降分析法和预测分析法是常用的自顶向下的语法分析。</p></li><li><p>语法制导翻译是一种静态语义分析方法</p></li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>面向对象&#x3D;对象+分类+继承+通过消息的通信</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p>描述一组对象的共同行为和属性</p></li><li><p>类是对象的抽象，对象是类的具体化</p></li><li><p>类可以分为三种：实体类、接口类(边界)、控制类</p><ul><li>实体类的对象表示现实世界中真实的实体，如：人和物<ul><li>实体类用于是应用领域中的核心类，一般用于<strong>保存系统中的信息</strong>，以及提供针对这些<strong>信息的相关处理行为</strong></li></ul></li><li>接口类（边界）的对象为用户提供一种与系统合作<strong>交互</strong>的方式，分为人和系统两大类</li><li>控制类的对象用来控制活动流 ，负责实体类和界面类的交互，充当协调者</li></ul></li><li><p>有些类之间存在一般和特殊的关系，一般即父类，特殊即子类</p></li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>对象是基本的运行时的实体</li><li>一个对象通常由对象名、属性(状态）、方法三个部分组成</li></ul><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><ul><li>对象之间进行的一种构造叫做消息</li></ul><h2 id="方法重载和重写"><a href="#方法重载和重写" class="headerlink" title="方法重载和重写"></a>方法重载和重写</h2><ul><li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<ul><li>参数不同可以是：参数的个数不同、参数的类型不同、参数类型的顺序不同</li></ul></li><li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变</li><li>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法</li></ul><h2 id="封装继承多态"><a href="#封装继承多态" class="headerlink" title="封装继承多态"></a>封装继承多态</h2><ul><li><p>多态：不同的对象收到同一消息可以产生完全不同的结果，多态的实现受到继承的支持，利用类的继承的层次关系。客户无需知道所调用的方法的特定子类的实现</p></li><li><p>多态的类型</p><ul><li>参数多态：被称为最纯的多态</li><li>包含多态：子类型化，即一个类型是另一个类型的子类型</li><li>过载多态：同一个名字在不同的上下文中所代表的含义不同。</li></ul></li></ul><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><ul><li>静态绑定：在编译时进行的</li><li>动态绑定：在运行时进行的（支持多态）</li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul><li><p>单一责任原则：就一个类而言，应该仅有一个引起它变化的原因</p></li><li><p>开发封闭原则：可以拓展，不可以修改</p></li><li><p>里氏替换原则：子类必须能够替换掉他们的父类</p></li><li><p>依赖倒置原则：高层模块不依赖低层模块，依赖于抽象，而不依赖于实现（细节）</p></li><li><p>接口分离原则：依赖于抽象，而不依赖于具体</p></li><li><p>共同重用原则：重用了包中的一个类，就要重用包中的所有类</p></li><li><p>共同封闭原则：一个变化若对一个包产生影响，则将对该包中的所有类产生影响</p></li></ul><h2 id="分析设计程序设计测试"><a href="#分析设计程序设计测试" class="headerlink" title="分析设计程序设计测试"></a>分析设计程序设计测试</h2><p>分析（OOA）</p><ul><li>面向对象分析包含5个活动:认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息。</li></ul><p>设计（OOD）</p><ul><li>OOD在复用OOA模型的基础上，包含与OOA对应如下五个活动：识别类及对象。定义属性。定义服务。识别关系。识别包。</li></ul><p>程序设计</p><ul><li>选择合适的面向对象程序设计语言，将程序组织为相互协作的对象</li></ul><p>测试</p><ul><li>测试的4个层次：算法层、类层、模板层、系统层</li></ul><h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><p>UML 中有 4 种事物:结构事物、行为事物、分组事物和注释事物。</p><ul><li>(1)结构事物(Structural Thing)。结构事物是 UML模型中的名词。它们通常是模型的静态部分,描述概念或物理元素。结构事物包括类(Class)、接口(Interface)协作(Collaboration).用例(Use Case)、主动类 (Active Class)、构件(Component)、制品 (Artifact) 和结点 (Node)。</li><li>(2)行为事物(Behavior thing)。行为事物是 UML模型的动态部分。它们是模型中的动词，描述了跨越时间和空间的行为。行为事物包括交互 (Interaction)、状态机(State Machine) 和活动 (Activity)。</li><li>(3)分组事物(Grouping Thing)。分组事物是 UML模的组织部分，是一些由模型分解成的“盒子”。在所有的分组事物中，最主要的分组事物是包 (Package)。包是把元素组织成组的机制，结构事物、行为事物甚至其他分组事物都可以放进包内。这种机制具有多种用途。与构件(仅在运行时存在) 不同它纯粹是概念上的(即它仅在开发时存在)。</li><li>（4）注释事物 (Amnotational Thing)。注释事物是 UML模型的解释部分。这些注释事物用来描述、说明和标注模型的任何元素。注解 (Note) 是一种主要的注释事物。注解是一个依附于一个元素或者一组元素之上，对它进行约束或解释的简单符号。</li></ul><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>UML 中有 4种关系:依赖、关联、泛化和实现。</p><ul><li>(1)依赖 (Dependency)。依赖是两个事物间的语义关系，其中一个事物 (独立事物)发生变化会影响另一个事物(依赖事物)的语义</li><li>(2)关联(Association)。关联是一种结构关系，<strong>在图中用一条实心的直线表示</strong>，它描述了一组链，链是对象之间的连接聚集 (Ageregation)是一种特殊类型的关联，它描述了整体和部分间的结构关系，聚合和组合是特殊的关联。</li><li><strong>聚合</strong>: 部分和整体的生命周期不一致，整体消失了，部分仍然存在部分可以脱离整体存在。</li><li><strong>组合</strong>:部分和整体的生命周期一致，整体消失了，部分也消失了部分不可以脱离整体而存在。用<strong>实心菱形</strong>表示 靠近实心的类是整体 直线另一头是部分</li><li>关联多重度：<strong>多重度</strong>表示关联关系中一个类与另一个类的实例之间的数量关系。 它可以是一对一的关系（1:1）、一对多的关系（1:N）、多对一的关系（N:1）或多对多的关系（N:N）<strong>两个类可以有多个关联</strong>，但是关联<strong>需要由不同角色进行标识</strong></li><li>（3)泛化(Generalization)。泛化是一种<strong>特殊&#x2F;一般关系</strong>，特殊元素(子元素)的对象可替代一般元素(父元素)的对象。用这种方法，子元素共享了父元素的结构和行为。在图形上,把一个泛化关系画成<strong>一条带有空心箭头的实线，它指向父元素</strong></li><li>(4)实现(Realization)。实现是类元之间的语以关系，其中一个类元指定了由另一个类元保证执行的契约。在两种情况下会使用实现关系:一种是在接口和实现它们的类或构件之间;另一种是在用例和实现它们的协作之间。在图形上，把一个实现关系<strong>画成一条带有空心箭头的虚线</strong></li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图(Diagram)是一组元素的图形表示，大多数情况下把图画成顶点(代表事物)和弧(代表关系)的连通图。为了对系统进行可视化，可以从不同的角度画图，这样图是对系统的投影。UML 2.0 提供了 13 种图，分别是类图、对象图、用例图、序列图、通信图、状态图、活动图、构件图、组合结构图、部署图、包图、交互概览图和计时图。序列图、通信图、交互概览图和计时图均被称为交互图</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>类图 (Class Diagram)展现了<strong>一组对象、接口、协作和它们之间的关系</strong>。在面向对象系统的建模中所建立的最常见的图就是类图。类图给出系统的静态设计视图。</p><p>类图中通常包括下述内容</p><ul><li>类</li><li>接口</li><li>协作</li><li>依赖</li><li>泛化和关联关系</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323857.png" alt="image-20231012164441556"></p><h3 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h3><ul><li>对象图 (Object Diagram)展现了<strong>某一时刻一组对象以及它们之间的关系</strong></li><li>描述了在类图中所建立的事物的实例的静态快照。</li><li>对象图一般包括对象和链，如图 7-12 所示。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323041.png" alt="image-20231013102811959"></p><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><ul><li>用例图(Use Case Diagram)展现了<strong>一组用例、参与者 (Actor)以及它们之间的关系</strong>。</li><li>用例图通常包括以下内容</li></ul><ol><li>用例。</li><li>参与者。</li><li>用例之间的扩展关系 (&lt;<extend>&gt;) 和包含关系 (&lt;<include>&gt;)，参与者和用例之间的关联关系，用例与用例以及参与者与参与者之间的泛化关系。</include></extend></li></ol><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323536.png" alt="image-20231013103055149"></p><h3 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h3><ul><li>序列图 (Sequence Diagram)是场景 (Scenario)的图形化表示，描述了以时间顺序组织的对象之间的交互活动。<strong>一个用例的多个对象行为</strong></li><li>序列图有对象生命线。对象生命线是一条垂直的虚线，表示一个对象在一段时间内存在。在交互图中出现的大多数对象存在于整个交互过程中，所以这些对象全都排列在图的顶部,</li><li>序列图有控制焦点。控制焦点是一个瘦高的矩形，表示一个对象执行一个动作所经历的时间段，既可以是直接执行，也可以是通过下级过程执行。矩形的顶部表示动作的开始，底部表示动作的结束</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323539.png" alt="image-20231013103317706"></p><h3 id="通信图（协作图）"><a href="#通信图（协作图）" class="headerlink" title="通信图（协作图）"></a>通信图（协作图）</h3><ul><li>通信图(Communication Diagram)强调收发消息的对象的结构组织</li><li>通信图强调参加交互的对象的组织</li><li>通信图有两个不同于序列图的特性<ol><li>通信图有路径。为了指出一个对象如何与另一个对象链接，可以在链的末端附上一个路径构造型<ol><li>通信图有顺序号。为表示一个消息的时间顺序，可以给消息加一个数字前缀 (从1号消息开始)，在控制流中，每个新消息的顺序号单调增加(如 2、3 等)。</li></ol></li></ol></li></ul><p><img src="/2024/04/28/%E8%BD%AF%E8%80%83/Users\Atdote\AppData\Roaming\Typora\typora-user-images\image-20231013103948934.png" alt="image-20231013103948934"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><ul><li><strong>是一个对象执行一系列的结果</strong></li><li>状态图 (State Diagram)展现了一个状态机，它由状态、转换、事件和活动组成。</li><li>状态图关注系统的动态视图，对于接口、类和协作的行为建模尤为重要，强调对象行为的事件顺序。</li></ul><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><ul><li><p>转换是两个状态之间的一种关系，表示对象将在源状态中执行一定的动作，并在某个特定事件发生而且某个特定的警界(监护)条件满足时进入目标状态。</p></li><li><p>转换包括两个状态</p></li><li><p><strong>事件触发转换 (迁移)</strong></p></li><li><p>活动 (动作)可以在状态内执行，也可以在状态转换 (迁移) 时执行。</p></li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323915.png" alt="image-20231013105251508"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323433.png" alt="image-20231013105530687"></p><p>​<strong>状态图</strong></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323122.png" alt="image-20231013104831706"></p><p>组合状态也叫超状态  是状态里面嵌套状态</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323109.png" alt="image-20231013105044457"></p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><ul><li>活动图 (Activity Diagram)是一种特殊的状态图，它展现了在系统内从<strong>一个活动到另一个活动的流程</strong>，</li><li>如图 7-19 所示。活动图专注于系统的动态视图，它对于系统的功能建模特别重要并强调对象间的控制流程。</li><li>适合用在工作流和操作流</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323473.png" alt="image-20231013110016131"></p><h3 id="构件图（组件图）"><a href="#构件图（组件图）" class="headerlink" title="构件图（组件图）"></a>构件图（组件图）</h3><ul><li>构件图(Component Diagram)展现了<strong>一组构件之间的组织和依赖</strong>。</li><li>构件图专注于系统的静态实现视图，如图 7-20 所示。它与类图相关，通常把构件映射为一个或多个类、接口或协作。</li><li>构建图的标记<img src="/2024/04/28/%E8%BD%AF%E8%80%83/Users\Atdote\AppData\Roaming\Typora\typora-user-images\image-20231013110412103.png" alt="image-20231013110412103"></li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323516.png" alt="image-20231013110344589"></p><h3 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h3><ul><li>部署图(Deployment Diagram)是用来对面向对象系统的<strong>物理方面建模</strong>的方法</li><li>展现了运行时处理结点以及其中构件(制品)的配置。</li><li>在实施阶段使用</li><li>部署组件类似于包依赖，依赖是非双向的</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323908.png" alt="image-20231013110603160"></p><h3 id="图的总结"><a href="#图的总结" class="headerlink" title="图的总结"></a>图的总结</h3><ul><li>静态建模:类图、对象图、用例图</li><li>动态建模：状态图、活动图 、通信图(协作图)、序列图(顺序图，时序图)</li><li>物理建模:构件图(组件图)、部署图</li><li>交互图: 序列图(顺序图，时序图) 、通信图(协作图)</li></ul><p>系统的静态设计视图建模时，通常以下述 3 种方式之一使用类图</p><ul><li><strong>(1)对系统的词汇建模。</strong>对系统的词汇建模涉及做出这样的决定:哪些抽象是考虑中的系统的一部分，哪些抽象处于系统边界之外。用类图详细描述这些抽象和它们的职责。</li><li><strong>(2)对简单的协作建模</strong>。协作是一些共同工作的类、接口和其他元素的群体，该群体提供的一些合作行为强于所有这些元素的行为之和。例如，当对分布式系统的事务语义建模时，不能仅仅盯着一个单独的类来推断要发生什么，而要有相互协作的一组类来实现这些语义。用类图对这组类以及它们之间的关系进行可视化和详述。</li><li><strong>(3)对逻辑数据库模式建模</strong>。将模式看作为数据库的概念设计的蓝图。在很多领域中，要在关系数据库或面向对象数据库中存储永久信息，可以用类图对这些数据库的模式建模。</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li><p>“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心这样，你就能一次又一次地使用该方案而不必做重复劳动”。</p></li><li><p>设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便地<strong>复用</strong>成功的设计和体系结构。</p></li><li><p>一般四要素</p><ol><li>模式名称</li><li>问题</li><li>解决方案</li><li>效果</li></ol><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323997.png" alt="image-20231013111307078"></p></li></ul><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><h3 id="Factory-Method（工厂设计模式）"><a href="#Factory-Method（工厂设计模式）" class="headerlink" title="Factory Method（工厂设计模式）"></a>Factory Method（工厂设计模式）</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><ul><li>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323596.png" alt="image-20231013230950600"></p><h4 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h4><p>Factory Method 模式适用于:</p><ul><li>当一个类不知道它所必须创建的对象的类的时候。</li><li>当一个类希望由它的子类来指定它所创建的对象的时候。</li><li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li></ul><h3 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory(抽象工厂)"></a>Abstract Factory(抽象工厂)</h3><h4 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h4><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323426.png" alt="image-20231013231247398"></p><h4 id="适用性-1"><a href="#适用性-1" class="headerlink" title="适用性"></a>适用性</h4><p>Abstract Factory 模式适用于:</p><ul><li>一个系统要独立于它的产品的创建、组合和表示时一个系统要由多个产品系列中的一个来配置时。</li><li>当要强调一系列相关的产品对象的设计以便进行联合使用时。</li><li>当提供一个产品类库，只想显示它们的接口而不是实现时。</li></ul><h3 id="Build（生成器）"><a href="#Build（生成器）" class="headerlink" title="Build（生成器）"></a>Build（生成器）</h3><h4 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h4><ul><li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062323299.png" alt="image-20231013231624442"></p><h4 id="适用性-2"><a href="#适用性-2" class="headerlink" title="适用性"></a>适用性</h4><p>Builder 模式适用于:</p><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。当构造过程必须允许被构造的对象有不同的表示时</li></ul><h3 id="Prototype-原型"><a href="#Prototype-原型" class="headerlink" title="Prototype(原型)"></a>Prototype(原型)</h3><h4 id="意图-3"><a href="#意图-3" class="headerlink" title="意图"></a>意图</h4><ul><li>用原型实例指定创建对象的种类，并且通过<strong>复制</strong>这些原型创建新的对象。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324260.png" alt="image-20231013232527428"></p><h3 id="Singleton-单例"><a href="#Singleton-单例" class="headerlink" title="Singleton(单例)"></a>Singleton(单例)</h3><h4 id="意图-4"><a href="#意图-4" class="headerlink" title="意图"></a>意图</h4><ul><li>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324665.png" alt="image-20231013232736022"></p><h4 id="适用性-3"><a href="#适用性-3" class="headerlink" title="适用性"></a>适用性</h4><p>Singleton 模式适用于:</p><ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时。</li></ul><h2 id="结构性设计模式"><a href="#结构性设计模式" class="headerlink" title="结构性设计模式"></a>结构性设计模式</h2><h3 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter(适配器)"></a>Adapter(适配器)</h3><h4 id="意图-5"><a href="#意图-5" class="headerlink" title="意图"></a>意图</h4><ul><li>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类<strong>可以一起工作</strong>。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324870.png" alt="image-20231013233031627"></p><h4 id="适用性-4"><a href="#适用性-4" class="headerlink" title="适用性"></a>适用性</h4><p>Adapter 适用于:</p><ul><li>想使用一个已经存在的类而它的接口不符合要求</li><li>想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作。</li><li>（仅适用于对象 Adapter）想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ul><h3 id="Bright-桥接"><a href="#Bright-桥接" class="headerlink" title="Bright(桥接)"></a>Bright(桥接)</h3><h4 id="意图-6"><a href="#意图-6" class="headerlink" title="意图"></a>意图</h4><ul><li>将抽象部分与其实现部分分离，使它们都可以独立地变化。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324120.png" alt="image-20231013233330261"></p><h4 id="适用性-5"><a href="#适用性-5" class="headerlink" title="适用性"></a>适用性</h4><p>Bridge模式适用于:</p><ul><li>不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</li><li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 Bridge 模式使得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。(C++) 想对客户完全隐藏抽象的实现部分。</li><li>有许多类要生成的类层次结构。</li><li>想在多个对象间共享实现(可能使用引用计数)，但同时要求客户并不知道这一点。</li></ul><h3 id="Composite-组合"><a href="#Composite-组合" class="headerlink" title="Composite(组合)"></a>Composite(组合)</h3><h4 id="意图-7"><a href="#意图-7" class="headerlink" title="意图"></a>意图</h4><ul><li>​将对象组合成树型结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324602.png" alt="image-20231013233656115"></p><h3 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="Decorator(装饰器)"></a>Decorator(装饰器)</h3><h4 id="意图-8"><a href="#意图-8" class="headerlink" title="意图"></a>意图</h4><ul><li>动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324562.png" alt="image-20231013234025313"></p><h4 id="适用性-6"><a href="#适用性-6" class="headerlink" title="适用性"></a>适用性</h4><p>Decorator 模式适用于:</p><ul><li>在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责</li><li>处理那些可以撤销的职责。</li><li>当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能由于类定义被隐藏，或类定义不能用于生成子类。</li></ul><h3 id="Facade-外观"><a href="#Facade-外观" class="headerlink" title="Facade(外观)"></a>Facade(外观)</h3><h4 id="意图-9"><a href="#意图-9" class="headerlink" title="意图"></a>意图</h4><p>使得这一子系统更加密易使用<br>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324266.png" alt="image-20231013234322747"></p><h4 id="适用性-7"><a href="#适用性-7" class="headerlink" title="适用性"></a>适用性</h4><p>Facade 模式适用于:</p><ul><li>要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制,但也给那些不需要定制子系统的用户带来一些使用上的困难Facade 可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 Facade 层。</li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</li><li>当需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，则可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系。</li></ul><h3 id="Flyweight-享元"><a href="#Flyweight-享元" class="headerlink" title="Flyweight(享元)"></a>Flyweight(享元)</h3><h4 id="意图-10"><a href="#意图-10" class="headerlink" title="意图"></a>意图</h4><ul><li>运用共享技术有效地支持大量细粒度的对象</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324925.png" alt="image-20231013234605006"></p><h4 id="适用性-8"><a href="#适用性-8" class="headerlink" title="适用性"></a>适用性</h4><p>Flyweight 模式适用于:</p><ul><li>一个应用程序使用了大量的对象。</li><li>完全由于使用大量的对象，造成很大的存储开销。</li><li>对象的大多数状态都可变为外部状态。如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。</li><li>应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，所以对于概念上明显有别的对象，标识测试将返回真值。</li></ul><h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy(代理)"></a>Proxy(代理)</h3><h4 id="意图-11"><a href="#意图-11" class="headerlink" title="意图"></a>意图</h4><p>为其他对象提供一种代理以控制对这个对象的访问</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324348.png" alt="image-20231013234804354"></p><h4 id="适用性-9"><a href="#适用性-9" class="headerlink" title="适用性"></a>适用性</h4><p>Proxy 模式适用于</p><ul><li>远程代理 (Remote Proxy)为一个对象在不同地址空间提供局部代表</li><li>虚代理(Virtual Proxy) 根据需要创建开销很大的对象。</li><li>保护代理 (Protection Proxy) 控制对原始对象的访问，用于对象应该有不同的访问权限的时候。</li><li>智能引用(Smart Reference) 取代了简单的指针，它在访问对象时执行一些附加操作典型用途包括:对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放:当第一次引用一个持久对象时，将它装入内存:在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li></ul><h2 id="行为设计模式"><a href="#行为设计模式" class="headerlink" title="行为设计模式"></a>行为设计模式</h2><h3 id="（Command）命令模式"><a href="#（Command）命令模式" class="headerlink" title="（Command）命令模式"></a>（Command）命令模式</h3><h4 id="意图-12"><a href="#意图-12" class="headerlink" title="意图"></a>意图</h4><ul><li>将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化;</li><li>对请求排队或记录请求日志，以及支持可撤销的操作。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324729.png" alt="image-20231014105449399"></p><h4 id="适用性-10"><a href="#适用性-10" class="headerlink" title="适用性"></a>适用性</h4><p>Command模式适用于:</p><ul><li>抽象出待执行的动作以参数化某对象。Command 模式是过程语言中的回调(Callback)机制的一个面向对象的替代品。</li><li>在不同的时刻指定、排列和执行请求。</li><li>支持取消操作。</li><li>支持修改日志。</li><li>用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务(Transaction)的信息系统中很常见。Command 模式提供了对事务进行建模的方法。Command 有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统。</li></ul><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="意图-13"><a href="#意图-13" class="headerlink" title="意图"></a>意图</h4><ul><li>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324607.png" alt="image-20231014111822110"></p><h3 id="State-状态模式"><a href="#State-状态模式" class="headerlink" title="(State)状态模式"></a>(State)状态模式</h3><h4 id="意图-14"><a href="#意图-14" class="headerlink" title="意图"></a>意图</h4><ul><li>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324074.png" alt="image-20231015103718066"></p><h4 id="适用性-11"><a href="#适用性-11" class="headerlink" title="适用性"></a>适用性</h4><p>State 模式适用于:</p><ul><li>一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。</li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="意图-15"><a href="#意图-15" class="headerlink" title="意图"></a>意图</h4><ul><li>定义一系列的算法，把它们-个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324577.png" alt="image-20231015105458208"></p><h4 id="适用性-12"><a href="#适用性-12" class="headerlink" title="适用性"></a>适用性</h4><p>Strategy 模式适用于:</p><ul><li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置个类的方法。</li><li>需要使用一个算法的不同变体。例如，定义一些反映不同空间的空间&#x2F;时间权衡的算法当这些变体实现为一个算法的类层次时，可以使用策略模式。</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li><li>一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的 Strategy 类中，以代替这些条件语句。</li></ul><h3 id="（Visitor）访问者模式"><a href="#（Visitor）访问者模式" class="headerlink" title="（Visitor）访问者模式"></a>（Visitor）访问者模式</h3><h4 id="意图-16"><a href="#意图-16" class="headerlink" title="意图"></a>意图</h4><ul><li>表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324077.png" alt="image-20231015110345843"></p><h4 id="适用性-13"><a href="#适用性-13" class="headerlink" title="适用性"></a>适用性</h4><p>Visitor 模式适用于:</p><ul><li>一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作“污染”这些对象的类。Visitor 使得用户可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用 Visitor 模式让每个应用仅包含需要用到的操作。</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变那么可能还是在这些类中定义这些操作较好。</li></ul><h1 id="知识产权"><a href="#知识产权" class="headerlink" title="知识产权"></a>知识产权</h1><h2 id="著作权"><a href="#著作权" class="headerlink" title="著作权"></a>著作权</h2><ul><li>也称为版权，是指作者对其创作的作品享有的人身权和财产权<ul><li>人身权包括：发表权（有时间性），署名权，修改权，保护作品完整权</li></ul></li></ul><h2 id="专利地域性"><a href="#专利地域性" class="headerlink" title="专利地域性"></a>专利地域性</h2><ul><li>各国主管机关依照本国法律授予的知识产权，只能在其本国领域内受法律保护</li></ul><h2 id="计算机软件著作权"><a href="#计算机软件著作权" class="headerlink" title="计算机软件著作权"></a>计算机软件著作权</h2><ul><li><p>主体：指享有著作权的人</p></li><li><p>客体：计算机程序及计算机软件文档</p><ul><li>计算机程序包括：源程序和目标程序</li><li>文档包括：程序设计说明书，流程图，用户手册</li></ul></li><li><p>两个文件：著作权法和计算机软件保护条例</p></li><li><p>权利：人身权和财产权</p><ul><li>人身权包括：发表权，署名权（开发者身份权）</li></ul></li><li><p>保护期：50年（除开发者身份权外）</p></li></ul><h2 id="职务作品和委托开发"><a href="#职务作品和委托开发" class="headerlink" title="职务作品和委托开发"></a>职务作品和委托开发</h2><p>职务作品</p><ul><li>职务作品只享有署名权，其他的著作权属于该单位</li><li>个人作品要同时符号以下条件<ul><li>所开发的软件作品不是执行其本职工作的结果。</li><li>开发的软件作品与开发者在单位中从事的工作内容无直接联系。</li><li>开发的软件作品未使用单位的物质技术条件。</li></ul></li></ul><p>委托开发</p><ul><li>委托开发软件著作权的归属与所签合同一致，若如何中未指明，则归属于受委托方</li></ul><h2 id="商业秘密权和商标"><a href="#商业秘密权和商标" class="headerlink" title="商业秘密权和商标"></a>商业秘密权和商标</h2><p>商业秘密权</p><ul><li>指不为公众所知悉的、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息</li></ul><p>商标权</p><ul><li>我国商标权的保护期限自核准注册之日起10年内有效，但可以根据其所有人的需要无限地延长权利期限。</li></ul><p>商标注册权</p><ul><li>先注册先得，同一天注册的先使用先得，再不行就协商解决。</li></ul><h2 id="专利权"><a href="#专利权" class="headerlink" title="专利权"></a>专利权</h2><ul><li>两个或者两个以上的人分别就同样的发明创造申请专利的，专利权授给最先申请人。</li></ul><h1 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h1><p>信息安全包括5个基本要素:机密性、完整性、可用性、可控性与可审查性</p><ul><li>机密性:确保信息不暴露给未授权的实体或进程。</li><li>完整性:只有得到允许的人才能修改数据，并且能够判别出数据是否已被篡改。</li><li>可用性:得到授权的实体在需要时可访问数据，即攻击者不能占用所有的资源而阻碍授权者的工作。</li><li>可控性:可以控制授权范围内的信息流向及行为方式。</li><li>可审查性:对出现的信息安全问题提供调查的依据和手段。</li></ul><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ul><li><p>对通过受控干线的任何通信行为进行安全处理，如控制、审计、报警和反应等</p></li><li><p>防火墙工作<strong>层次越高</strong>，<strong>工作效率越低</strong>，<strong>安全性越高</strong></p></li><li><p>DMZ位于内网和外网之间，用于保存公用的服务器</p></li><li><p>防火墙技术经历了<strong>包过滤</strong>、<strong>应用代理网关</strong>和<strong>状态检测技术</strong>三个发展阶段。</p></li><li><p>包过滤防火墙</p><ul><li>包过滤器处在网络层和数据链路层（即TCP和P层)之间</li><li>对用户完成透明，速度快</li><li>每个IP包的字段都被检查，如：源地址、目的地址、协议、端口号等</li><li>对包实习低水平控制，安全性低，不支持应用层协议</li></ul></li><li><p>应用代理网关防火墙</p><ul><li>彻底隔离：内网用户对外网的访问变成防火墙对外网的访问，然后再由防火墙转发给内网用户</li><li>难以配置，速度慢</li></ul></li><li><p>状态检测防火墙</p><ul><li>结合了代理防火墙的安全性和包过滤防火墙的高速度等优点</li></ul></li></ul><h2 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a>病毒</h2><ul><li>病毒的特征：传播性、隐蔽性、感染性、潜伏性、触发性、破坏性等</li><li>Worm表示蠕虫病毒、Trojan表示特洛伊木马、Backdoor表示后门病毒、Macro表示宏病毒</li><li>宏病毒感染的对象主要是文本文档、电子表格等</li><li>特洛伊木马：感染后会有未知程序试图建立网络连接</li><li>蠕虫病毒:欢乐时光、熊猫烧香、红色代码、爱虫病毒、震网</li><li>木马软件:冰河，木马病毒：X卧底</li></ul><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><ul><li>入侵检测技术:专家系统、模型检测、简单匹配</li></ul><p>常见的网络攻击</p><ul><li><p>拒绝服务攻击（Dos攻击）:目的是使计算机或网络无法提供正常的服务</p><ul><li>拒绝服务攻击是不断向计算机发起请求来实现的</li></ul></li><li><p>重放攻击:攻击者发送一个目的主机已经接受过的报文来达到攻击目的</p></li><li><p>Sql注入攻击:是黑客对数据库进行攻击的常用手段之一。</p><ul><li>没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。</li><li>攻击者可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，首先获取数据库的权限，就可获取用户账号和口令信息，以及对某些数据修改等。</li></ul></li><li><p>攻击者利用网络监听或者其他方式盗取认证凭据，之后再重新发送给认证服务器。主要用于身份认证过程,目的是破坏认证的正确性。</p></li><li><p>口令入侵攻击:使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动</p></li><li><p>特洛伊木马:被伪装成程序或游戏，当用户下载了带有木马的软件或附件时，这个程序就会向黑客发起连接请求，建立连接后黑客就实施攻击活动。</p></li><li><p>网络监听:攻击者可以接收某一网段在同一条物理通道上传输的所有信息，使用网络监听可以轻松截取包括账号和口令在内的信息资料</p></li><li><p>IP欺骗攻击:产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份。</p></li><li><p>端口欺骗攻击:采用端口扫描找到系统漏洞从而实施攻击</p></li><li><p>ARP攻击：通过伪造P地址和MAC地址，造成无法跨网段通信</p></li></ul><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><ul><li>SSL（安全套接层）：传输层安全协议，端口号是443</li><li>TLS：传输层安全协议，是SSL3.0的后续版本</li><li>SSH：在终端设备与远程站点之间建立安全连接的协议，建立在应用层和传输层基础上</li><li>HTTPS：以安全为目标的HTTP通道，即使用SSL加密算法的HTTP</li><li>MIME：是一个互联网标准，扩展了电子邮件标准 </li><li>PGP：是一个基于RSA公钥加密体系的邮件加密软件</li></ul><h2 id="杂题-1"><a href="#杂题-1" class="headerlink" title="杂题"></a>杂题</h2><ul><li><p>用户权限：所有用户＞用户组＞高级用户＞管理员</p></li><li><p>IIS身份验证安全机制：基本身份验证＞.NET Passport身份验证＞摘要式身份验证＞集成Windows身份验证</p></li><li><p>公共端口号：0-1023，HTTP端口号：80（不安全），HTTPS端口号：443（安全），POP3端口号：110</p></li><li><p>IPSec可以为IP数据报文进行加密，PPSP可以为链路加密</p></li><li><p>Telnet：不安全的远程登入协议，RFB：远程登入图形化用户界面协议，IGMP：因特网组管理协议</p></li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><p>按网络设备分</p><ul><li>物理层：中继器 集线器</li><li>数据链路层： 网桥 交换机</li><li>网络层：路由器</li><li>应用层：网关</li></ul><p>按范围分</p><ul><li>局域网（LAN）</li><li>城域网（MAN）</li><li>广域网（WAN）</li><li>因特网</li></ul><p>按拓扑结构分</p><ul><li>总线型</li><li>星型</li><li>环型</li></ul><h2 id="七层网络体系结构（OSI）"><a href="#七层网络体系结构（OSI）" class="headerlink" title="七层网络体系结构（OSI）"></a>七层网络体系结构（OSI）</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062324068.png" alt="image-20231015223706935"></p><ul><li>DHCP：使网络环境中的主机动态的获得<strong>IP地址</strong>、<strong>DHCP服务器地址</strong>、<strong>DNS服务器地址</strong>、<strong>默认网关</strong>等信息，并能够提升地址的使用率。</li><li>169.254.X.X是 Windows系统在DHCP信息租用失败时自动给客户机分配的IP地址。0.0.0.0是Linux的</li></ul><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP&#x2F;IP协议族"></a>TCP&#x2F;IP协议族</h2><ul><li><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325181.png" alt="image-20231015224452259">TC</p></li><li><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325410.png" alt="image-20231015223706935">P&#x2F;IP协议是Internet的基础和核心,从上而下分为：应用层、传输层、网际层、网络接口层</p></li><li><p>应用层：</p><ul><li><p>FTP：上传文件端口为20 控制端口为21</p></li><li><p>邮件分发：</p><ul><li>SMTP：简单邮件传输协议 ，只能传输ASCII码文本和文字附件， 端口号：25 ，采用C&#x2F;S模式</li><li>POP3：邮件传输协议 ，与SMTP配合使用 以E-mail为单位，不能提供部分传输 ，端口号：110 采用C&#x2F;S模式<ol><li>SMTP：发</li><li>POP3：收</li><li>MIME：扩</li></ol></li></ul><p>DNS：域名查询顺序：1.本地host文件 2.本地DNS缓存 3.本地DNS服务器 4.根域名服务器</p></li></ul></li><li><p>网际层协议：ARP、RARP、IP、ICMP</p><ul><li>ARP：地址解析协议(Address Resolution Protocol, ARP)，ARP的作用是将IP地址转换为物理地址，以<strong>广播</strong>请求，<strong>单播</strong>响应</li><li>RARP：反地址解析协议(RARP)，RARP的作用是将物理地址转换为IP地址</li><li>IP协议是网际层的核心，通过路由选择将下一跳IP封装后交给网络接口层。IP数据报是无连接服务。</li><li>ICMP：ICMP是网际层的补充，（利用ip传送）可以回送报文。用来检测网络是否通畅（使用ping命令)。</li></ul></li><li><p>TCP和UDP</p><ul><li>TCP：TCP(Transmission Control Protocol,传输控制协议)，为应用程序提供了一个可靠的、面向连接的数据传输服务。只能点到点的连接</li><li>UDP：用户数据报协议(User Datagram Protocol, UDP)是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信。面向报文，没有拥塞控制，开销小，支持多种连接方式</li><li>TCP有助于提供可靠性，而UDP则有助于提高传输的高速率性。</li></ul></li></ul><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><p>TCP:</p><ul><li>有连接 可靠 速度较慢</li><li>流量控制和连接管理</li><li>拥堵控制</li><li>有差值效验和重传</li></ul><p>UDP：</p><ul><li>无连接 不可靠 速度快</li><li>开销较小</li></ul><p>共同点：</p><ul><li>端口寻址</li></ul><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li>协议名:&#x2F;&#x2F;主机名.域名.域名后缀.域名分类&#x2F;目录&#x2F;网页文件</li><li>浏览器默认的应用层协议为：HTTP</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325884.png" alt="image-20231016112229044"></p><h2 id="IP地址和IPv6"><a href="#IP地址和IPv6" class="headerlink" title="IP地址和IPv6"></a>IP地址和IPv6</h2><p>IP地址</p><ul><li><p>IP地址的长度为32位，分为4段，每段8位，每段数字范围为0-255</p></li><li><p>IP地址由两部分组成，一部门为网络地址，一部分为主机地址</p><ul><li>网络地址又被分为网络号和子网号（子网号是从主机地址借来的）</li><li>主机地址全为1时称为广播地址，全1时为网络地址</li></ul></li><li><p>IP地址分为5类</p><ul><li>A类：由1个字节的网络地址和3个字节的主机地址组成，网络地址的最高位必须是0，地址范围是1.0.0.1～126.255.255.254。可用的A类网络有126个，每个网络地址能容纳2^24-2个主机</li><li>B类IP地址。由2个字节的网络地址和2个字节的主机地址组成，网络地址的取同位必须是“10”，地址范围是128.0.0.0～191.255.255.254。可用的B类网络有16384个，每个网络能容纳65534个主机。</li><li>C类P地址。由3个字节的网络地址和1个字节的主机地址组成，网络地址的取同位必须是“110”，地址范围是192.0.1.1~223.255.255.254。可用的C类网络有2^21-2个个，每个网络能容纳254个主机。</li><li>D类IP地址。第一个字节以“1110”开始，是专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播(Multicast)中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。D类P地址的地址范围是224.0.0.1~239.255.255.254。</li><li>E类IP地址。以“1111”开始，为将来使用保留，仅做实验和开发用。</li></ul></li></ul><p>IPV6</p><ul><li>IPv6地址长度为128位，地址空间增大了2^96倍</li><li>简化了报文头部格式，字段只有8个，加快了报文处理速度</li></ul><h2 id="Internet服务"><a href="#Internet服务" class="headerlink" title="Internet服务"></a>Internet服务</h2><ul><li>DNS域名服务：DNS用的是UDP端口，端口号是53。<ul><li>协议名:&#x2F;&#x2F;主机名.域名.域名后缀.域名分类&#x2F;目录&#x2F;网页文件</li></ul></li><li>远程登录服务：Telnet协议用的是TCP端口，端口号一般是23。</li><li>电子邮件服务：传送协议SMTP和接收邮件的POP3，两者均利用TCP端口<ul><li>SMTP所用的端口号是25 ，只能传送ASCII格式的报文</li><li>POP3所用的端口号是110，用CS模式进行通信，</li></ul></li><li>WWW服务：WWW服务（HTTP）是一种交互式图形界面的Internet服务，具有强大的信息连接功能。WWW用的是TCP端口，端口号是80。</li><li>文件传输服务：FTP在客户机与服务器的内部建立两条TCP连接<ul><li>一条是控制连接，主要用于传输命令和参数(端口号是21)</li><li>另一条是数据连接，主要用于传送文件(端口号是20)。</li></ul></li></ul><h2 id="Windows命令"><a href="#Windows命令" class="headerlink" title="Windows命令"></a>Windows命令</h2><p>windows</p><ul><li><p>ipconfig:显示所有网络适配器的P地址、子网掩码和缺省网关值</p></li><li><p>ipconfig&#x2F;release: DHCP客户端手工释放IP地址</p></li><li><p>ipconfig&#x2F;flushdns:清除本地DNS缓存内容</p></li><li><p>ipconfig&#x2F;displaydns:显示本地 DNS内容</p></li><li><p>ipconfig&#x2F;registerdns: DNS客户端手工向服务器进行注册</p></li><li><p>ipconfig&#x2F;all:显示所有网络适配器的完整TCP&#x2F;IP配置信息，包括DHCP服务是否已启动</p></li><li><p>ipconfig&#x2F;renew: DHCP客户端手工向服务器刷新请求（重新申请IP地址)</p></li><li><p>netstat：显示网络连接、路由表和网络接口信息</p></li><li><p>nslookup：用于查询Internet域名信息</p></li><li><p>tracert：是路由跟踪实用程序，用于确定P数据包访问目标所采取的路径</p></li></ul><p>ping的顺序</p><ul><li>使用 ping 命令进行网络检测，按照由近及远原则<ol><li>首先执行的是 ping 127.0.0.1</li><li>其次是 ping本地IP</li><li>再次是 ping 默认网关</li><li>最后是 ping 远程主机。</li></ol></li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由类型</p><table><thead><tr><th>路由类型</th><th>说明</th></tr></thead><tbody><tr><td>直连网络ID</td><td>用于直接连接的网络，Interface(或next hop）可以为空</td></tr><tr><td>远程网络ID</td><td>用于不直接连接的网络，可以通过其他路由器到达这种网络Interface字段是本地路由器的P地址</td></tr><tr><td>主机路由</td><td>到达特定主机的路由，子网掩码为255.255.255.255</td></tr><tr><td>默认路由</td><td>无法找到确定路由时使用的路由，目标网络和网络掩码都是0.0.0.0</td></tr><tr><td>持久路由</td><td>利用route add -p命令添加的表项，每次初始化时，这种路由都会加入Windows的注册表中，同时加入路由表</td></tr></tbody></table><ul><li>当Windows服务器收到一个IP数据包时，<ul><li>先查找主机路由</li><li>再查找网络路由(直连网络和远程网络)</li><li>这些路由查找失败时，最后才查找默认路由。</li></ul></li></ul><p>路由的管理距离</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325039.png" alt="image-20231016153618415"></p><ul><li>如果路由器收到了由多个路由协议转发的、关于某个目标的多条路由，则比较各个路由的管理距离，并采用管理距离小的路由来源提供的路由信息。</li></ul><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul><li>广播域：网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围</li><li>冲突域：两台计算机在同时通信时会发生冲突，就是一个冲突域</li><li>物理层不能隔离广播域和冲突域</li><li>数据链路层不能隔离广播域，但能隔离冲突域</li><li>网络层能隔离广播域和冲突域</li><li>集线器是一种多端口的中继器 ，交换机是多端口的网桥</li><li>蓝牙的覆盖范围是最小的，通信距离是最短的</li><li>DNS域名查询的次序是:本地的hosts文件→本地DNS缓存→本地DNS服务器→根域名服务器。</li><li>主域名服务器在接收到域名请求后，查询顺序是本地缓存→本地hosts文件→本地数据库→转发域名服务器。</li><li>三网合一：电信网、广播电视网、互联网</li><li>网络的可用性：用户可利用网络时间的百分比</li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="范式："><a href="#范式：" class="headerlink" title="范式："></a>范式：</h2><h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式[2NF]"></a>第二范式[2NF]</h3><ul><li><p>2NF在1NF的基础之上，消除了非主属性对于主属性的部分函数依赖</p></li><li><p>简单的说，是表中的非主属性必须<strong>完全依赖于主属性</strong>(所谓完全依赖是指不能存在仅依赖候选键一部分的属性)</p></li><li><p>学生基本信息表(学号，身份证号，姓名)中，当然学号属性取值是唯一的。而(学号，身份证号)-&gt;(姓名)， (学号)-&gt;(姓名)， (身份证号)-&gt;(姓名)所以姓名部分函数依赖于(学号，身份证号) ;</p></li></ul><h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式[3NF)"></a>第三范式[3NF)</h3><ul><li>第三范式(3NF)就是指表中的所有数据元素不但要能唯一地被主关键字所标识而且它们之间还必须相互独立,不存在其他的函数关系。</li><li>也就是说，在2NF的基础上<strong>消除传递函数依赖</strong></li><li>所谓传递函数依赖，指的是如果存在“A一B一C”的决定关系，则C传递函数依赖于A</li></ul><h3 id="第四范式-4NF"><a href="#第四范式-4NF" class="headerlink" title="第四范式[4NF]"></a>第四范式[4NF]</h3><ul><li>第四范式是 消除表中的多值依赖以解决信息冗余，达到“一事一地”也就是<strong>一对一</strong>的关系</li></ul><h2 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h2><h3 id="1-排它锁"><a href="#1-排它锁" class="headerlink" title="(1) 排它锁"></a>(1) 排它锁</h3><ul><li>若事务T对数据对象 A 加上X锁，则只允许T读取和修改A</li><li>其他事务都不能再对 A加任何类型的锁，直到T释放 A 上的锁</li></ul><h3 id="2-共享锁"><a href="#2-共享锁" class="headerlink" title="(2) 共享锁"></a>(2) 共享锁</h3><ul><li>若事务T对数据对象 A 加上S 锁，则只允许T读取 A，但不能修改 A，其他事务只能再对 A 加S 锁，直到T释放 A 上的S 锁</li><li>这就保证了其他事务可以读 A，但在T释放 A 上的 S 锁之前不能对 A 进行任何修改。、</li></ul><h2 id="分布式数据库："><a href="#分布式数据库：" class="headerlink" title="分布式数据库："></a>分布式数据库：</h2><ul><li>分片透明: 指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的复制透明:指采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的。</li><li>位置透明:指用户无须知道数据存放的物理位置</li><li>逻辑透明:指用户或应用程序无需知道局部场地使用的是哪种数据模型</li><li>共享性:指数据存储在不同的结点数据共享</li><li>自治性:指每结点对本地数据都能独立管理</li><li>可用性:指当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪</li><li>分布性:指数据在不同场地上的存储</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统在计算机系统中的地位如下图所示</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325416.png" alt="image-20231016154637282"></p><h2 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h2><p>程序顺序执行时的主要特征包括</p><ul><li>顺序性</li><li>封闭性</li><li>可再现性</li></ul><p>前趋图是一个有向无循环图，由结点和有向边组成，结点代表各程序段的操作，而结点间的有向边表示两个程序段操作之间存在的前趋关系(一&gt;)。程序段 Pi和 Pj的前趋关系表示成Pi–&gt;Pj，其中，Pi是Pj的前趋，Pj是Pi的后继，其含义是Pi执行结束后P才能执行。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325130.png" alt="image-20231016155550767"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325708.png" alt="image-20231016161529923"></p><h2 id="程序并发执行的特征"><a href="#程序并发执行的特征" class="headerlink" title="程序并发执行的特征"></a>程序并发执行的特征</h2><p>若在计算机系统中采用多道程序设计技术，则主存中的多道程序可处于并发执行状态。对于上述有 3 个程序段的作业类，虽然每个作业有前趋关系的各程序段不能在 CPU 和输入&#x2F;输出各部件并行执行，<strong>但是同一个作业内没有前趋关系的程序段或不同作业的程序段可以分别在CPU 和各输入&#x2F;输出部件上并行执行</strong>。例如，某系统中有一个 CPU、一台输入设备和一台输出设备，每个作业具有3 个程序段输入I，计算 C和输出 P(&#x3D;1.2.3)。图 4-2为3 个作业的各程序段并发执行的前驱图。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325658.png" alt="image-20231016185643642"></p><p>从图4-2 中可以看出，I与 C 并行执行:I、C,与P并行执行:C;与P并行执行。其中,I、I受到L的间接制约，C、C;受到 C 的间接制约，P、P;受到 P的间接制约，而 C、P受到I的直接制约，等等。</p><h3 id="程序并发执行时的特征如下"><a href="#程序并发执行时的特征如下" class="headerlink" title="程序并发执行时的特征如下"></a>程序并发执行时的特征如下</h3><ol><li>失去了程序的封闭性</li><li>程序和机器的执行程序的活动不再一一对应</li><li>并发程序间的相互制约性</li><li>结果可能不一样</li></ol><h2 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h2><p>在多道程序系统中，进程在处理器上交替运行，状态也不断地发生变化，因此进程一般有3 种基本状态:运行、就绪和阻寒。图 4-3 显示了进程基本状态及其转换，也称三态模型。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325303.png" alt="image-20231016190117121"></p><ul><li>(1)运行。当一个进程在处理机上运行时，则称该进程处于运行状态。显然，对于单处理机系统，处于运行状态的进程只有一个。</li><li>(2) 就绪。一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。</li><li>(3)阻塞。阻塞也称等待或睡眠状态，一个进程正在等待某一事件发生(例如请求 I&#x2F;O 等待 IO 完成等)而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</li><li><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325949.png" alt="image-20231016191653803"></li></ul><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><ul><li>信号量 S 的物理意义:待该资源的进程数。</li><li>S&gt;0 表示某资源的可用数，若 S&lt;0，则其绝对值表示阻塞队列中等</li></ul><p>P 操作和 V 操作是低级通信原语，在执行期间不可分。其中，P 操作表示<strong>申请</strong>一个资源，V操作表示<strong>释放</strong>一个资源。</p><h2 id="利用-PV-操作实现进程的互斥"><a href="#利用-PV-操作实现进程的互斥" class="headerlink" title="利用 PV 操作实现进程的互斥"></a>利用 PV 操作实现进程的互斥</h2><p>令信号量 mutex 的初值为 1，当进入临界区时执行 P操作，退出临界区时执行 V 操作。这样，利用 PV 操作实现进程互斥的代码段如下:</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325452.png" alt="image-20231016203022924"></p><h2 id="利用-PV-操作实现进程的同步"><a href="#利用-PV-操作实现进程的同步" class="headerlink" title="利用 PV 操作实现进程的同步"></a>利用 PV 操作实现进程的同步</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325054.png" alt="image-20231016213212039"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>同类资源分配不当引越死锁。若系统中有 m 个资源被 n 个进程共享，当每个进[例 4.6]程都要求k个资源，而 m&lt;nk 时，即资源数小于进程所要求的总数时，<strong>可能</strong>会引起死锁。例如，m&#x3D;5，n&#x3D;3，k3，若系统采用的分配策略是<strong>轮流</strong>地为每个进程分配，则第一轮系统先为每个进程分配一台，还剩下两台;第二轮系统再为两个进程各分配一台，此时，系统中已无可供分配的资源，使得各个进程都处于等待状态导致系统发生死锁。</p><ul><li><strong>若 m&gt;&#x3D;n(k-1)+1就不会死锁 为假则可能会发生死锁（只适用于软考）</strong></li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325092.png" alt="image-20231016225744608"></p><h2 id="进程资源图"><a href="#进程资源图" class="headerlink" title="进程资源图"></a>进程资源图</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062325055.png" alt="image-20231017091958002"></p><p>化简：非阻塞将资源释放回去，可能会使其他进程也变为非阻塞状态 </p><ul><li>可以化简 –&gt;非死锁</li><li>不可以化简–&gt;死锁</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326369.png" alt="image-20231017092309073"></p><h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>死锁避免<br>死锁预防是设法破坏产生死锁的 4 个必要条件之一，严格防止死锁的产生。死锁避免则不那么严格地限制产生死锁的必要条件。最著名的死锁避免算法是 Diikstra 提出的银行家算法<br>死锁避免算法需要很大的系统开销。银行家算法对于进程发出的每一个系统可以满足的资源请求命令加以检测，如果发现分配资源后系统进入不安全状态，则不予分配;若分配资源后系统仍处于安全状态，则实施分配。与死锁预防策略相比，它提高了资源的利用率，但检测分配资源后系统是否安全增加了系统开销。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326060.png" alt="image-20231017095242890"></p><p>先进行P4进程   R1-1+P4  得 R1 R2 R3：2 3 1  后面的以此类推</p><h2 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326602.png" alt="image-20231017111142952"></p><h2 id="段页式存储模式"><a href="#段页式存储模式" class="headerlink" title="段页式存储模式"></a>段页式存储模式</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326138.png" alt="image-20231017152058969"></p><h2 id="单缓冲区"><a href="#单缓冲区" class="headerlink" title="单缓冲区"></a>单缓冲区</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326585.png" alt="image-20231017155618109"></p><h2 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h2><p><img src="/2024/04/28/%E8%BD%AF%E8%80%83/Users\Atdote\AppData\Roaming\Typora\typora-user-images\image-20231017155554649.png" alt="image-20231017155554649"></p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326074.png" alt="image-20231017161409287"></p><p><img src="/2024/04/28/%E8%BD%AF%E8%80%83/Users\Atdote\AppData\Roaming\Typora\typora-user-images\image-20231017161433713.png" alt="image-20231017161433713"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326817.png" alt="image-20231017161458584"></p><h2 id="旋转调度算法"><a href="#旋转调度算法" class="headerlink" title="旋转调度算法"></a>旋转调度算法</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326770.png" alt="image-20231017164524662"></p><h3 id="处理时间："><a href="#处理时间：" class="headerlink" title="处理时间："></a>处理时间：</h3><ul><li>经过一个记录的时间：20&#x2F;10&#x3D;2ms</li><li>处理一个记录的时间：4ms</li><li>优化算法用的时间：（2+4）*10&#x3D;60ms</li><li>非优化算法用的时间：4+2+[(20-4)+2+4]*(10-1)&#x3D;6+198&#x3D;204ms</li></ul><h2 id="多级索引结构"><a href="#多级索引结构" class="headerlink" title="多级索引结构"></a>多级索引结构</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326756.png" alt="image-20231017213305204"></p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>文件控制块文件控制块中包含以下三类信息: 基本信息类、存取控制信息类和使用信息类。</p><ul><li>崩溃对计算机系统影响较大</li><li>基本信息类。例如文件名、文件的物理地址、文件长度和文件块数等。</li><li>存取控制信息类。文件的存取权限，像 UNIX 用户分成文件主、同组用户和一般用户三类，这三类用户的读&#x2F;写执行 RWX 权限。</li><li>使用信息类。文件建立日期、最后一次修改日期、最后一次访问的日期、当前使用的信息(如打开文件的进程数、在文件上的等待队列) 等。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><a href="https://blog.csdn.net/qq_50954361/article/details/127894032">软件设计师—数据结构_软件开发邻接矩阵形式技术_骚戴的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_50954361/article/details/127894032">https://blog.csdn.net/qq_50954361/article/details/127894032</a></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><ul><li>(1)双亲、孩子和兄弟。结点的子树的根称为该结点的孩子;相应地，该结点称为其子结点的双亲。具有相同双亲的结点互为兄弟。</li><li>(2) 结点的度。一个结点的子树的个数记为该结点的度。例如，图 3-16 中，A 的度为 3,B 的度为 2，C的度为 0，D 的度为 1。</li><li>(3) 叶子结点。叶子结点也称为终端结点，指度为 0 的结点。例如，图 3-16 中，E、F、C、G 都是叶子结点。</li><li>(4)内部结点。度不为 0 的结点，也称为分支结点或非终端结点。除根结点以外，分支结点也称为内部结点。例如，图 3-16 中，B、D 都是内部结点。</li><li>(5) 结点的层次。根为第一层，根的孩子为第二层，依此类推，若某结点在第i层，则其孩子结点在第+1层。例如，图 3-16 中，A 在第1层，B、C、D 在第2 层，E、F和G在第 3 层。</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326177.png" alt="image-20231024010600942"></p><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><p>性质1</p><ul><li>树中的<strong>结点总数</strong>等于树中<strong>所有结点的度数之和</strong>再<strong>加1</strong></li></ul><p>性质2</p><ul><li>度为 m 的树中第i层上<strong>至多</strong>有 <strong>m^(i-1)</strong> 个结点 (i&gt;1)</li></ul><p>性质3</p><ul><li>高度为h的m次树 最多有(m^h-1)&#x2F;(m-1)</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>性质1：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326698.png" alt="image-20231024234016276"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062326001.png" alt="image-20231024233914301"></p><p>1</p><h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h2><p>CMM 将软件过程改进分为以下5个成熟度级别。</p><ol><li>**初始级(Initial)**：软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的成功完全依赖个人的努力和英雄式核心人物的作用。</li><li>**可重复级 (Repeatable)**：建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功。</li><li>**已定义级(Defimed)**：管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</li><li>**已管理级(Managed)**：制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织的成员所理解和控制。</li><li>**优化级(Optimized)**：加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。</li></ol><p>CMMI 是CMM的改进</p><h2 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h2><p>CMMI 提供了两种表示方法: 阶段式模型和连续式模型。</p><p><strong>阶段式模型(不怎么考)</strong><br>阶段式模型的结构类似于 CMM，它关注组织的成熟度。CMMI-SE&#x2F;SW&#x2F;IPPD 1.1 版中有5个成熟度等级。</p><ul><li>初始的:过程不可预测且缺乏控制。</li><li>已管理的:过程为项目服务。</li><li>已定义的:过程为组织服务</li><li>定量管理的:过程已度量和控制。</li><li>优化的:集中于过程改进。</li></ul><p><strong>连续式模型</strong></p><ul><li>CL0(未完成的): 过程域<strong>未执行</strong>或<strong>未得到</strong> CL1中定义的所有目标。</li><li>CL1(已执行的): 其共性目标是过程将<strong>可标识的输入工作产品</strong>转换成<strong>可标识的输出工作产品</strong>，以实现支持过程域的特定目标。</li><li>CL2(已管理的): 其<strong>共性目标</strong>集中于<strong>已管理</strong>的过程的<strong>制度化</strong>。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审。</li><li>CL3(已定义级的): 其<strong>共性目标</strong>集中于<strong>已定义</strong>的过程的<strong>制度化</strong>。过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。</li><li>CL4(定量管理的): 其共性目标集中于<strong>可定量管理</strong>的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则。</li><li>CL5(优化的):使用<strong>量化(统计学) 手段改进</strong>和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效。</li></ul><h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型为软件的开发和维护提供了一种有效的管理模式，根据这一模式制定开发计划，进行成本预算，组织开发力量，以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，所以它是以文档作为驱动、<strong>适合于软件需求很明确的软件项目的模型</strong>。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062327885.png" alt="image-20231018171013812"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>方便理解 适用于有明确的分析</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>维护成本高 不适应与变化的项目</li></ul><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>瀑布模型的一个变体是V模型，如图 5-3 所示。V 模型描述了质量保证活动和沟通、建模相关活动以及早期构建相关的活动之间的关系。随着软件团队工作沿着V模型左侧步骤向下推进，基本问题需求逐步细化，形成问题及解决方案的技术描述。一旦编码结束，团队沿着V模型右侧的步骤向上推进工作，其实际上是执行了一系列测试(质量保证活动)，这些测试验证了团队沿着 V 模型左侧步骤向下推进过程中所生成的每个模型。V模型提供了一种将验证确认活动应用于早期软件工程工作中的方法。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062327059.png" alt="image-20231018171647173"></p><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>增量模型融合了瀑布模型的基本成分和原型实现的迭代特征，它假设可以将需求分段为系列增量产品，每一增量可以分别开发。该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”，如图 5-4 所示。当使用增量模型时，第1个增量往往是核心的产品。客户对每个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。<strong>增量模型强调每一个增量均发布一个可操作的产品。</strong><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062327849.png" alt="image-20231018191715328"></p><p>增量模型作为瀑布模型的一个变体，<strong>具有瀑布模型的所有优点</strong>。此外，它还有以下优点:<strong>第一个可交付版本所需要的成本和时间很少</strong>:开发由增量表示的小系统所承担的风险不大;由于很快发布了第一个版本，因此可以减少用户需求的变更:运行增量投资，即在项目开始时,可以仅对一个或两个增量投资。<br>增量模型有以下不足之处:<strong>如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定</strong>: 如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布:<strong>管理发生的成本、进度和配置的复杂性可能会超出组织的能力</strong>。</p><h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3><p>并非所有的需求都能够预先定义，大量的实践表明，在开发初期很难得到一个完整的、准确的需求规格说明。这主要是由于客户往往不能准确地表达对未来系统的全面要求，开发者对要解决的应用问题模糊不清，以至于形成的需求规格说明常常是不完整的、不准确的，有时甚至是有歧义的。此外，在整个开发过程中，用户可能会产生新的要求，导致需求的变更。而深布模型难以适应这种需求的不确定性和变化，于是出现了快速原型 (Rapid Prototype) 这种新的开发方法。原型方法比较<strong>适合于用户需求不清、需求经常变化的情况</strong>。当<strong>系统规模不是很大也不太复杂时，采用该方法比较好。</strong></p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>快速低成本</li><li>原型方法比较适合于用户需求不清、需求经常变化的情况，当系统规模不是很大时</li><li>用户能够摸得着 能更好的得到客户意见 </li><li>能够更好捕获需求</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不适合规模大的软件</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062327541.png" alt="image-20231018211530023"></p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>对于<strong>复杂的大型软件</strong>，开发一个原型往往达不到要求。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的<strong>风险分析</strong>，弥补了这两种模型的不足。<br>螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合，如图 5-6所示。每个螺旋周期分为如下 4 个工作步骤。<br>(1) 制订计划。确定软件的目标，选定实施方案，明确项目开发的限制条件.<br>(2) 风险分析。分析所选的方案，识别风险，消除风险。<br>(3) 实施工程。实施软件开发，验证阶段性产品。<br>(4) 用户评估。评价开发工作，提出修正建议，建立下一个周期的开发计划</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062327254.png" alt="image-20231018212907984"></p><p>螺旋模型<strong>强调风险分析</strong>，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型特别<strong>适用于庞大、复杂并且具有高风险的系统。</strong></p><p>与瀑布模型相比，螺旋模型<strong>支持用户需求的动态变化</strong>，为用户参与软件开发的所有关键决策提供了方便，有助于提高软件的适应能力，并且为项目管理人员及时调整管理决策提供了便利，从而<strong>降低了软件开发的风险</strong>。在使用螺旋模型进行软件开发时，需要开发人员具有相当丰富的风险评估经验和专门知识。另外，过多的迭代次数会增加开发成本，延迟提交时间。</p><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>喷泉模型是一种以用户需求为动力,以对象作为驱动的模型，<strong>适合于面向对象</strong>的开发方法。它克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。喷泉模型使开发过程具有<strong>迭代性</strong>和<strong>无间隙性</strong>，如图 5-7 所示。迭代意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统。无间隙是指在开发活动(如分析、设计、编码) 之间不存在明显的边界，也就是说，它不像瀑布模型那样，在需求分析活动结束后才开始设计活动，在设计活动结束后才开始编码活动而是<strong>允许各开发活动交叉、迭代地进行</strong>。</p><p>喷泉模型的<strong>各个阶段没有明显的界线</strong>，<strong>开发人员可以同步进行</strong>。其优点是<strong>可以提高软件项目的开发效率</strong>，<strong>节省开发时间</strong>。由于喷泉模型在各个开发阶段是重叠的,在开发过程中<strong>需要大量的开发人员</strong>,<strong>不利于项目的管理</strong>。此外，这种模型<strong>要求严格管理文档</strong>，<strong>使得审核的难度加大</strong>。</p><h2 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h2><p>敏捷开发的总体目标是通过“尽可能早地、持续地对有价值的软件的交付”使客户满意通过在软件开发过程中加入灵活性，敏捷方法使用户能够在开发周期的后期增加或改变需求。</p><h3 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h3><ul><li><p>XP 是一种轻量级(敏捷)、高效、低风险、柔性、可预测的、科学的软件开发方式。它由价值观、原则、实践和行为 4个部分组成，彼此相互依赖、关联、周期。并通过行为贯穿于整个生存</p></li><li><p>4 大价值观:沟通、简单性、反馈和勇气。</p></li><li><p>5 个原则:快速反馈、简单性假设、逐步修改、提倡更改和优质工作</p></li><li><p><strong>12 个最佳实践:</strong></p></li></ul><ol><li>计划游戏(快速制定计划、随着细节的不断变化而完善)、</li><li>小型发布(系统的设计要能够尽可能早地交付)、</li><li>隐喻(找到合适的比喻传达信息)、</li><li>简单设计(只处理当前的需求，使设计保持简单)、</li><li>测试先行(先写测试代码，然后再编写程序)、</li><li>重构(重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求)、</li><li>结队编程、集体代码所有制、持续集成(可以按日甚至按小时为客户提供可运行的版本).每周工作40个小时、现场客户和编码标准。</li></ol><h3 id="水晶法"><a href="#水晶法" class="headerlink" title="水晶法"></a>水晶法</h3><ul><li>水晶法认为每一个不同的项目都需要一套不同的策略、约定和方法论</li></ul><h3 id="并列争求法"><a href="#并列争求法" class="headerlink" title="并列争求法"></a>并列争求法</h3><ul><li>并列争求法使用迭代的方法，其中，把每 30 天一次的迭代称为一个“冲刺”，并按需求的优先级别来实现产品。多个自组织和自治的小组并行地递增实现产品。</li></ul><h3 id="自适应软件开发"><a href="#自适应软件开发" class="headerlink" title="自适应软件开发"></a>自适应软件开发</h3><ul><li>有6个基本的原则:有一个使命作为指导:特征被视为客户价值的关键点;过程中的ASD等待是很重要的，因此“重做”与“做”同样关键;变化不被视为改正，而是被视为对软件开发实际情况的调整:确定的交付时间迫使开发人员认真考虑每一个生产的版本的关键需求:风险也包含其中。</li></ul><h3 id="敏捷统一过程"><a href="#敏捷统一过程" class="headerlink" title="敏捷统一过程"></a>敏捷统一过程</h3><p>敏捷统一过程(Agile Unified Process，AUP)采用“<strong>在大型上连续</strong>”以及在“<strong>在小型上迭代</strong>”的原理来构建软件系统。采用经典的UP 阶段性活动(初始、精化、构建和转换)，提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。在每个活动里，一个团队迭代使用敏捷，并将有意义的软件增量尽可能快地交付给最终用户。每个 AUP 迭代执行以下活动:</p><ul><li>建模。建立对商业和问题域的模型表述，这些模型“足够好”即可，以便团队继续前进。</li><li>实现。将模型翻译成源代码。</li><li>测试。像 XP 一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求部署。对软件增量的交付以及获取最终用户的反馈。</li><li>配置及项目管理。着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动。</li><li>环境管理。协调标准、工具以及适用于开发团队的支持技术等过程基础设施。</li></ul><h2 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h2><ul><li>(1）功能需求。考虑系统要做什么，在何时做，在何时以及如何修改或升级。</li><li>(2)性能需求。考虑软件开发的技术性指标。例如，存储容量限制、执行速度、响应时间及吞吐量。</li><li>(3) 用户或人的因素。考虑用户的类型。例如，各种用户对使用计算机的熟练程度，需要接受的训练，用户理解、使用系统的难度，用户错误操作系统的可能性等。</li><li>(4)环境需求。考虑未来软件应用的环境，包括硬件和软件。对硬件设备的需求包括机型外设、接口、地点、分布、湿度、磁场干扰等;对软件的需求包括操作系统、网络、数据库等.</li><li>(5) 界面需求。考虑来自其他系统的输入，到其他系统的输出，对数据格式的特殊规定，对数据存储介质的规定。</li><li>(6) 文档需求。考虑需要哪些文档，文档针对哪些读者。</li><li>(7)数据需求。考虑输入、输出数据的格式，接收、发送数据的频率，数据的准确性和精度，数据流量，数据需保持的时间。</li><li>(8)资源使用需求。考虑软件运行时所需要的数据、其他软件、内存空间等资源: 软件开发、维护所需的人力、支撑软件、开发设备等。</li><li>(9)安全保密要求。考虑是否需要对访问系统或系统信息加以控制，隔离用户数据的方法用户程序如何与其他程序和操作系统隔离以及系统备份要求等。</li><li>(10)可靠性要求。考虑系统的可靠性要求，系统是否必须检测和隔离错误;出错后，重启系统允许的时间等。</li><li>(11)软件成本消耗与开发进度需求。考虑开发是否有规定的时间表，软&#x2F;硬件投资有无限制等</li><li>(12)其他非功能性要求。如采用某种开发模式，确定质量控制标准、里程碑和评审、验收标准、各种质量要求的优先级等，以及可维护性方面的要求。</li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h3><p>1.设计软件系统总体结构<br>其基本任务是采用某种设计方法，<strong>将一个复杂的系统按功能划分成模块</strong>:确定每个模块的功能:确定模块之间的调用关系:确定模块之间的接口，即模块之间传递的信息:评价模块结构的质量。</p><p>2.数据结构及数据库设计<br>数据结构的设计。逐步细化的方法也适用于数据结构的设计。在需求分析阶段，已经C通过数据字典对数据的组成、操作约束和数据之间的关系等方面进行了描述，确定了数据的结构特性，在概要设计阶段要加以细化，详细设计阶段则规定具体的实现细节。在概要设计阶段,宜使用抽象的数据类型。数据库的设计。数据库的设计是指数据存储文件的设计，主要进行以下几方面设计。</p><p>数据库的设计。数据库的设计是指数据存储文件的设计，主要进行以下几方面设计。</p><p>3.编写概要设计<br>文档主要有概要设计说明书、数据库设计说明书、用户手册以及修订测试计划。</p><p>4.评审</p><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><p>(1)对每个模块进行<strong>详细的算法设计</strong>用某种图形、表格和语言等工具将每个模块处理过<br>程的详细算法描述出来。<br>(2)对模块内的数据结构进行设计。<br>(3)对数据库进行物理设计，即确定数据库的物理结构。<br>(4)其他设计。根据软件系统的类型，还可能要进行以下设计。 </p><ul><li>代码设计。为了提高数据的输入、分类、存储和检索等操作，节约内存空间，对数据库中某些数据项的值要进行代码设计。</li><li>输入&#x2F;输出格式设计</li><li>用户界面设计</li></ul><p>(5)编写详细设计说明书<br>(6)评审。对处理过程的算法和数据库的物理结构都要评审</p><p>系统设计的结果是一系列的系统设计文件，这些文件是物理实现一个信息系统(包括硬设备和编制软件程序) 的重要基础。</p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>系统测试是<strong>为了发现错误而执行程序的过程</strong>，成功的测试是发现了至今尚未发现的错误的测试。</p><p>在进行信息系统测试时应遵循以下基本原则：</p><ul><li>(1) 应尽早并不断地进行测试</li><li>(2) 测试工作应该避免由原开发软件的人或小组承担</li><li>(3)在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果。</li><li>(4)在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件。在测试的时候，人们往往习惯按照合理的、正常的情况进行测试，而忽略了对异常不合理、意想不到的情况进行测试，而这可能就是隐患。</li><li>(5)在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。多余的工作会带来副作用，影响程序的效率，有时会带来潜在的危害或错误。</li><li>(6)严格按照测试计划来进行，避免测试的随意性。测试计划应包括测试内容、进度安排、人员安排、测试环境、测试工具和测试资料等。严格地按照测试计划可以保证进度，使各方面都得以协调进行。</li><li>(7) 妥善保存测试计划、测试用例，作为软件文档的组成部分，为维护提供方便。</li><li>(8)测试例子都是精心设计出来的，可以为重新测试或追加测试提供方便。</li><li>(9):系统测试阶段的测试目标<strong>来自于需求分析阶段</strong>。</li></ul><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>软件测试方法分为静态测试和<strong>动态测试</strong></p><p>动态测试。动态测试是指通过运行程序发现错误。在对软件产品进行动态测试时可以采用黑盒测试法和白盒测试法。</p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>黑盒测试也称为功能测试，在<strong>完全不考虑软件的内部结构和特性</strong>的情况下，测试软件的外部特性。进行黑盒测试主要是为了发现以下几类错误。</p><ol><li>是否有错误的功能或遗漏的功能?</li><li>界面是否有误?输入是否正确接收?输出是否正确?</li><li>是否有数据结构或外部数据库访问错误?</li><li>性能是否能够接受?</li><li>是否有初始化或终止性错误?</li></ol><p>常用的黑盒测试技术有等价类划分、边界值分析、错误推测和因果图等</p><h4 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h4><p>(1) 等价类划分。等价类划分法将程序的<strong>输入域划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例</strong>。每一类的代表性数据在测试中的作用等价于这一类中的其他值，这样就可以用少量代表性的测试用例取得较好的测试效果。等价类划分有两种不同的情况:有效等价类和无效等价类。在设计测试用例时，要同时考虑这两种等价类。</p><h5 id="有效等价类和无效等价类："><a href="#有效等价类和无效等价类：" class="headerlink" title="有效等价类和无效等价类："></a>有效等价类和无效等价类：</h5><p>例如： X属于：0<del>100  当X在0</del>100内 则X为有效等价类 反之为无效等价类</p><h4 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h4><p>边界值分析。输入的边界比中间更加容易发生错误，因此用边界值分析来补充等价类划分的测试用例设计技术。边界值划分选择等价类边界的测试用例，既注重于输入条件边界，又适用于输出域测试用例</p><h4 id="错误推测"><a href="#错误推测" class="headerlink" title="错误推测"></a>错误推测</h4><p>错误推测。错误推测是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例的方法。其基本思想是列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。</p><h4 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h4><p>因果图。因果图法是从自然语言描述的程序规格说明中找出因(输入条件)和果(输出或程序状态的改变)，通过因果图转换为判定表。</p><h3 id="McCabe-度量法"><a href="#McCabe-度量法" class="headerlink" title="McCabe 度量法"></a>McCabe 度量法</h3><p>McCabe 度量法是通过定义环路复杂度，建立程序复杂性的度量，它基于一个程序模块的程序图中环路的个数。计算有向图 G 的环路复杂性的公式为: V(G) &#x3D;m-n+2，其中V (G) 是有向图 G 中的环路个数，<strong>m 是G 中的有向弧数</strong>，<strong>n是 G中的节点数</strong>。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062346391.png" alt="image-20231019195706859"></p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><ul><li>白盒测试也称为结构测试，根据程序的<strong>内部结构</strong>和<strong>逻辑</strong>来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要。</li><li>白盒测试常用的技术是<strong>逻辑覆盖</strong>、<strong>循环覆盖</strong>和<strong>基本路径测试</strong>。</li></ul><h4 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h4><ol><li>语句覆盖。语句覆盖是指选择足够的测试数据，使被测试程序中的每条语句至少执行次。语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖。</li><li>判定覆盖。判定覆盖是指设计足够的测试用例，使得被测程序中的每个判定表达式至少获得一次“真”值和“假”值，或者说是程序中的每一个取“真”分支和取“假”分支至少都通过一次，因此判定覆盖也称为分支覆盖。判定覆盖要比语句覆盖更强一些。</li><li>条件覆盖。条件覆盖是指构造一组测试用例，使得每一判定语句中每个逻辑条件的种可能的值至少满足一次。</li><li>判定&#x2F;条件覆盖。判定&#x2F;条件覆盖是指设计足够的测试用例，使得判定中每个条件的所有可能取值(真&#x2F;假)至少出现一次，并使每个判定本身的判定结果 (真&#x2F;假) 也至少出现一次。</li><li>条件组合覆盖。条件组合覆盖是指设计足够的测试用例，使得每个判定中条件的各种可能值的组合都至少出现一次。满足条件组合覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定&#x2F;条件覆盖的。</li><li>路径覆盖。路径覆盖是指覆盖被测试程序中所有可能的路径</li></ol><h2 id="系统可维护性概念"><a href="#系统可维护性概念" class="headerlink" title="系统可维护性概念"></a>系统可维护性概念</h2><ul><li>可理解性</li><li>可测试性</li><li>可修改性</li></ul><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><ul><li>文档是软件可维护性的决定因素。由于长期使用的大型软件系统在使用过程中必然会<strong>经受多次修改</strong>，所以文档显得非常重要。</li><li>可维护性是所有软件都应具有的基本特点，必须在开发阶段保证软件具有可维护的特点。</li><li>软件维护要解决软件产品交付用户之后运行中发生的各种问题</li><li>软件的维护期通常比开发期长得多，其投入也大得多</li><li>进行质量保证审查可以提高软件产品的可维护性</li></ul><h4 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h4><ul><li>正确性维护。正确性维护是指<strong>改正</strong>在<strong>系统开发阶段已发生</strong>而<strong>系统测试阶段****尚未发现</strong>的<strong>错误</strong>。这方面的维护工作量要占整个维护工作量的 17%~21%。所发现的错误有的不太重要,不影响系统的正常运行，其维护工作可随时进行;而有的错误非常重要，甚至会影响整个系统的正常运行，其维护工作必须制定计划，进行修改，并且要进行复查和控制。</li><li>适应性维护。适应性维护是指使<strong>应用软件适应信息技术变化</strong>和<strong>管理需求变化</strong>而进行的修改。这方面的维护工作量占整个维护工作量的 18%~25%。由于目前计算机硬件价格不断下降，各类系统软件层出不穷，人们常常为改善系统硬件环境和运行环境而产生系统更新换代的需求;企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出新的信息需求。这些因素都将导致适应性维护工作的产生。进行这方面的维护工作也要像系统开发一样,有计划、有步骤地进行。</li><li>完善性维护。这是为<strong>扩充功能</strong>和<strong>改善性能</strong>而进行的修改，主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征。这些功能对完善系统功能是非（<strong>占比最大</strong>）</li><li>预防性维护。为了改进应用软件的可靠性和可维护性，为了适应未来的软&#x2F;硬件环境的变化，应主动增加预防性的新的功能，以使应用系统适应各类变化而不被淘汰。</li></ul><h3 id="软件文档"><a href="#软件文档" class="headerlink" title="软件文档"></a>软件文档</h3><ul><li>编写高质量文档可以提高软件开发的质量</li><li>文档也是软件产品的一部分，没有文档的软件就不能称之为软件软件文档的编制在软件开发工作中占有突出的地位和相当大的工作量高质量文档对于软件产品的效益有着重要的意义</li><li>总的来说，软件文档只好不坏，选项中说软件文档不好的就是不正确的</li><li>软件系统文档既包括有一定格式要求的规范文档，又包括系统建设过程中的各种来往文件、会议纪要、会计单据等资料形成的不规范文档</li><li>软件文档的编制在软件开发工作中占有突出的地位和相当大的工作量</li></ul><h2 id="MTTF"><a href="#MTTF" class="headerlink" title="MTTF"></a>MTTF</h2><ul><li>可靠性是指一个系统对于给定的时间间隔内、在给定条件下<strong>无失效运作</strong>的概率。 MTTF&#x2F; (1+MTTF)</li><li>可用性是在给定的时间点上，一个系统能够按照规格说明<strong>正确运作</strong>的概率MTBF&#x2F; (1+MTBF)</li><li>可维护性是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和<strong>资源完成维护活动</strong>的概率 1&#x2F; (1+MTTR)、</li></ul><h2 id="软件评估模型"><a href="#软件评估模型" class="headerlink" title="软件评估模型"></a>软件评估模型</h2><h3 id="COCOMO"><a href="#COCOMO" class="headerlink" title="COCOMO"></a>COCOMO</h3><p>COCOMO 模型是一种<strong>精确的</strong>、<strong>易于使用</strong>的成本估算模型。COCOMO 模型按其详细程度分为基本COCOMO 模型、中级 COCOMO 模型和详细 COCOMO 模型</p><ul><li><strong>基本</strong> COCOMO 模型是一个<strong>静态单变量模型</strong>，用于对整个软件系统进行估算</li><li><strong>中级</strong> COCOMO 模型是一个<strong>静态多变量模型</strong>，它将软件系统模型分为系统和部件两个层次，系统由部件构成，它把软件开发所需的人力(成本)看作是程序大小和一系列“成本驱动属性”的函数。</li><li><strong>详细</strong> COCOMO 模型，它将软件系统模型分为<strong>系统</strong>、<strong>子系统</strong>和<strong>模块</strong> 3 个层次，除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等每一步的成本驱动属性的影响</li></ul><h3 id="COCOMOII模型"><a href="#COCOMOII模型" class="headerlink" title="COCOMOII模型"></a>COCOMOII模型</h3><p>最初的 COCOMO 模型是得到产业界最广泛应用和讨论的软件成本估算模型之一，现在它已经演化成更全面的估算模型，称为 COCOMOII。和其前身一样，COCOMOII 也是一种层次结构的估算模型，被分为 3 个阶段性模型。</p><ul><li>应用组装模型</li><li>早期设计阶段模型</li><li>体系结构阶段模型</li></ul><p>有3种不同的规模估算选择:对象点、功能点和代码行 </p><ul><li>应用组装模型使用的是对象点</li><li>早期设计阶段模型使用的是功能点</li><li>功能点可以转换为代码行。</li></ul><h2 id="项目活动图"><a href="#项目活动图" class="headerlink" title="项目活动图"></a>项目活动图</h2><p>下图是一个软件项目的活动图，其中顶点表示项目里程碑，连接顶点的边表示活动边上的值表示完成活动所需要的时间，</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347204.png" alt="image-20231019212858938"></p><p>关键路径&#x3D;A C F G I (最长的路径)<br>关键路径的长度&#x3D;17<br>问某个顶点 或者 活动是否在关键路径上</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347290.png" alt="image-20231019213034552"></p><h2 id="软件配置管理"><a href="#软件配置管理" class="headerlink" title="软件配置管理"></a>软件配置管理</h2><ul><li>软件配置管理其主要目标包括:变更标识、变更控制、版本控制、确保变更正确的实现、变更报告、</li><li>软件配置管理其主要内容包括:版本管理、配置支持、变更支持、过程支持、团队支持、变化报告、审计支持</li><li>上下为两个不同的版本<br>软件配置管理其主要内容包括: 软件配置标识、变更管理、版本控制、系统建立、配置审核、配置状态报告。</li><li>配置数据库可以分为以下三类：<ul><li>开发库</li><li>受控库</li><li>产品库</li></ul></li></ul><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><ul><li>一般认为软件风险包含两个特性: 不确定性和损失</li><li>风险优先级根据风险暴露设定</li><li>风险不可能完全消除</li><li>风险检测不包括消除风险</li></ul><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><h3 id="ISO-IEC-9126"><a href="#ISO-IEC-9126" class="headerlink" title="ISO&#x2F;IEC 9126"></a>ISO&#x2F;IEC 9126</h3><p>ISO&#x2F;IEC 9126 软件质量模型由 3 个层次组成: 第一层是质量特性，第二层是质量子特性，第三层是度量指标。该模型的质量特性和质量子特性如图 5-15 所示。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347164.png" alt="image-20231020153214958"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347232.png" alt="image-20231020153404661"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347009.png" alt="image-20231020153423062"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347617.png" alt="image-20231020153454861"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347030.png" alt="image-20231020153526604"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347115.png" alt="image-20231020153604376"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347003.png" alt="image-20231020153618926"></p><h1 id="结构化开发"><a href="#结构化开发" class="headerlink" title="结构化开发"></a>结构化开发</h1><h2 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h2><ul><li>模块独立是指每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系简单</li><li>衡量模块独立程度的标准有两个:耦合性和内聚性。</li></ul><h3 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h3><p><strong>耦合是模块之间的相对独立性(互相连接的紧密程度)的度量</strong>。合取决于各个模块之间接口的复杂程度、调用模块的方式以及通过接口的信息类型等。一般模块之间可能的耦合方式有7种类型，如图 6-2 所示</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347408.png" alt="image-20231019225921229"></p><ul><li>无直接耦合。指两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，它们之间不传递任何信息。因此，模块间耦合性最弱，模块独立性最高。</li><li>数据耦合。指两个模块之间有调用关系，传递的是<strong>简单的数据值</strong>，相当于高级语言中的值传递。</li><li>标记耦合。指两个模块之间传递的是<strong>数据结构</strong></li><li>控制耦合。指一个模块调用另一个模块时，传递的是<strong>控制变量</strong>，被调用模块通过该控制变量的值有选择地执行模块内的某一功能。因此，被调用模块应具有多个功能，哪个功能起作用受调用模块控制</li><li>外部耦合。模块间通过<strong>软件之外的环境联结</strong>(如 IO 将模块合到特定的设备、格式通信协议上) 时称为外部耦合。</li><li>公共耦合。指通过一个<strong>公共数据环境</strong>相互作用的那些模块间的耦合。</li><li>内容耦合。当一个模块<strong>直接使用另一个模块的内部数据</strong>，或通过<strong>非正常入口</strong>转入另一个模块内部时，这种模块之间的耦合称为内容耦合。</li></ul><h3 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h3><p>内聚是对一个模块内部各个元素彼此结合的紧密程度的度量。一个内聚程度高的模块(在理想情况下)应当只做一件事。一般模块的内聚性分为7种类型，如图 6-3 所示。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062347583.png" alt="image-20231019233832011"></p><ul><li>偶然内聚(巧合内聚)。指一个模块内的各处理元素之间<strong>没有任何联系</strong>。</li><li>逻辑内聚。指模块内执行若干个<strong>逻辑上相似的功能</strong>，通过参数确定该模块完成哪一个功能。</li><li>时间内聚。把<strong>需要同时执行的动作组合</strong>在一起形成的模块称为时间内聚模块。</li><li>过程内聚。指一个模块完成多个任务，这些<strong>任务必须按指定的过程执行</strong>。</li><li>通信内聚。指模块内的所有处理元素都<strong>在同一个数据结构上操作</strong>，或者各<strong>处理使用相同的输入数据</strong>或者<strong>产生相同的输出数据</strong></li><li>顺序内聚。指一个模块中的各个处理元素都<strong>密切相关</strong>于同一功能且<strong>必须顺序执行</strong>，前一功能元素的输出就是下一功能元素的输入。</li><li>功能内聚。这是<strong>最强的内聚</strong>，指模块内的<strong>所有元素共同作用完成一个功能</strong>，缺一不可。</li></ul><h2 id="系统结构设计原则"><a href="#系统结构设计原则" class="headerlink" title="系统结构设计原则"></a>系统结构设计原则</h2><ol><li>分解-协调原则。整个系统是一个整体，具有整体目的和功能，但这些目的和功能的实现又是由相互联系的各个组成部分共同工作的结果。解决复杂问题的一个很重要的原则就是把它分解成多个小问题分别处理，在处理过程中根据系统总体要求协调各部门的关系。</li><li>自顶向下的原则。首先抓住系统总的功能目的，然后逐层分解，即先确定上层模块的功能，再确定下层模块的功能。</li><li>信息隐蔽、抽象的原则。上层模块只规定下层模块做什么和所属模块间的协调关系.但不规定怎么做，以保证各模块的相对独立性和内部结构的合理性，使得模块与模块之间层次分明，易于理解、实施和维护。</li><li>一致性原则。要保证整个软件设计过程中具有统一的规范、统一的标准和统一的文件模式等。</li><li>明确性原则。每个模块必须功能明确、接口明确，消除多重功能和无用接口。</li><li>高内聚低耦合原则。模块之间的耦合尽可能小，模块的内聚度尽可能高。</li><li>模块的扇入系数和扇出系数要合理。一个模块直接调用其他模块的个数称为模块的扇出系数;反之，一个模块被其他模块调用时，直接调用它的模块个数称为模块的扇入系数。模块的扇入、扇出系数必须适当。经验表明，一个设计得好的系统的平均扇入、扇出系数通常是3或4，一般不应超过 7，否则会引起出错概率的增大。但菜单调用型模块的扇入与扇出系数可以大一些，公用模块的扇入系数可以大一些.</li><li>模块的规模适当。过大的模块常常使系统分解得不充分，其内部可能包含了若干部分的功能，因此有必要进一步把原有的模块分解成若干功能尽可能单一的模块。但分解也必须适度，因为过小的模块有可能降低模块的独立性，造成系统接口的复杂性。</li><li>模块的作用范围应该在其控制制范围之内</li></ol><h2 id="系统文档"><a href="#系统文档" class="headerlink" title="系统文档"></a>系统文档</h2><p>对文档在系统开发人员、项目管理人员、系统维护人员、系统评价人员以及用户之间的多种作用总结如下。</p><ol><li><strong>用户</strong>与<strong>系统分析人员</strong>在系统规划和系统分析阶段通过文档进行沟通。这里的文档主要包括<strong>可行性研究报告</strong>、<strong>总体规划报告</strong>、<strong>系统开发合同</strong>和<strong>系统方案说明书</strong>等。</li><li><strong>系统开发人员</strong>与<strong>项目管理人员</strong>通过文档在项目期内进行沟通。这里的文档主要有<strong>系统开发计划(<strong>包括工作任务分解表、PERT 图、甘特图和预算分配表等)、</strong>系统开发月报</strong>以及<strong>系统开发总结报告</strong>等项目管理文件。</li><li>系统测试人员与系统开发人员通过文档进行沟通。系统测试人员可以根据系统方案说明书、系统开发合同、系统设计说明书和测试计划等文档对系统开发人员所开发的系统进行测试。</li><li>系统开发人员与用户在系统运行期间进行沟通。用户通过系统开发人员撰写的文档运行系统。这里的文档主要是用户手册和操作指南。</li><li>系统开发人员与系统维护人员通过文档进行沟通。这里的文档主要有系统设计说明书和系统开发总结报告。有的开发总结报告写得很详细，分为研制报告、技术报告和技术手册 3个文档，其中的技术手册记录了系统开发过程中的各种主要技术细节。</li><li>用户与维修人员在运行维护期间进行沟通。用户在使用信息系统的过程中，将运行过程中的问题进行记载，形成系统运行报告和维护修改建议。系统维护人员根据维护修改建议以及系统开发人员留下的技术手册等文档对系统进行维护和升级。</li></ol><h1 id="下午题"><a href="#下午题" class="headerlink" title="下午题"></a>下午题</h1><h2 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h2><p>数据流图也称数据流程图 (Data Flow Diaglam，<strong>DFD</strong>)，它是一种便于用户理解、分析系统数据流程的图形工具。它摆脱了系统的物理内容，精确地在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分</p><h3 id="1-数据流图的基本图形元素"><a href="#1-数据流图的基本图形元素" class="headerlink" title="1.数据流图的基本图形元素"></a>1.数据流图的基本图形元素</h3><p>数据流图中的基本图形元素包括**数据流(Data Flow)、加工(Process)、数据存储(Data Store)和外部实体(Extermal Agent)**。其中，数据流、加工和数据存储用于构建软件系统内部的数据处理模型:外部实体表示存在于系统之外的对象，用来帮助用户理解系统数据的来源和去向。DFD 的基本图形元素如图 6-8 所示。</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062348244.png" alt="image-20231021110457603"></p><h3 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h3><ul><li>外部实体:当前系统之外的人、物、外部系统</li><li>学生、老师、员工、主管、医生、客户、供应商…..</li><li>物:传感器、控制器、单车、车辆、采购部门….</li><li>外部系统:支付系统、车辆交易系统、库存管理系统、道闸控制系统.</li></ul><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ul><li>数据存储: 存储数据和提供数据</li><li>存储加工的输出数据和提供加工的输入数据</li><li>例子: 客户表、订单表、学生表、巴士列表文件、维修记录文件、课表文件</li></ul><h3 id="加工"><a href="#加工" class="headerlink" title="加工"></a>加工</h3><ul><li>加工:将输入数据处理后得到输出数据</li><li>一个加工至少有一个输入数据流和一个输出数据流</li><li>加工只有输入没有输出称为: 黑洞</li><li>加工只有输出没有输入称为: 白洞</li><li>加工的输入数据不足以产生输出数据: 灰洞</li></ul><h2 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h2><h3 id="一对多关系转化"><a href="#一对多关系转化" class="headerlink" title="一对多关系转化"></a>一对多关系转化</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062348947.png" alt="image-20231023003431900"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062348917.png" alt="image-20231023003441869"></p><h3 id="多对多联系转化"><a href="#多对多联系转化" class="headerlink" title="多对多联系转化"></a>多对多联系转化</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062348601.png" alt="image-20231023003541311"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405062348604.png" alt="image-20231023003551051"></p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计划书08</title>
      <link href="/2024/04/27/%E8%AE%A1%E5%88%92%E4%B9%A608-%E5%A4%8D%E4%B9%A0%E5%92%8C%E6%8E%A8%E8%BF%9B/"/>
      <url>/2024/04/27/%E8%AE%A1%E5%88%92%E4%B9%A608-%E5%A4%8D%E4%B9%A0%E5%92%8C%E6%8E%A8%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<p>计划书08-复习和推进</p><p>这几天也想写计划书 但是每次想写的时候都是很晚了 </p><p>有的时候有想法 但是又懒得打开 主要是之前没有弄图床 而且又一直在弄域名和个人博客 所以主线就落下了几天</p><p>今天打算先复习 然后写一下这几天个人博客搭建的过程 图床的过程</p><p>具体计划：</p><ol><li>完成“全面认识全过程人民民主”形策论文</li><li>写一篇图床的搭建过程</li><li>复习上次写的Spring八股和MySQL八股</li><li>推进主线 学习伙伴匹配系统 55~57</li></ol><p>加油加油🚀🚀🚀</p>]]></content>
      
      
      <categories>
          
          <category> 计划书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是索引 索引的底层结构是什么</title>
      <link href="/2024/04/26/MySql02-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2024/04/26/MySql02-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是索引-索引的底层结构是什么"><a href="#什么是索引-索引的底层结构是什么" class="headerlink" title="什么是索引 索引的底层结构是什么"></a>什么是索引 索引的底层结构是什么</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><ul><li>索引(index)是帮助MySQL高效获取数据的数据结构(有序)</li><li>提高数据检索的效率，降低数据库的IO成本(不需要全表扫描)</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><h2 id="索引的底层结构"><a href="#索引的底层结构" class="headerlink" title="索引的底层结构"></a>索引的底层结构</h2><p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p><p>B+树的优点：</p><ul><li>度数更多，路径更短</li><li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子节点存储数据</li><li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li></ul><h2 id="B-树-对比于其他树："><a href="#B-树-对比于其他树：" class="headerlink" title="B+树 对比于其他树："></a>B+树 对比于其他树：</h2><h3 id="B-树："><a href="#B-树：" class="headerlink" title="B+树："></a>B+树：</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102316350.png" alt="image-20240424135905792"></p><h3 id="B树"><a href="#B树" class="headerlink" title="B树:"></a>B树:</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102316740.png" alt="image-20240424135952546"></p><p>B树在于B+树的不同：</p><p>B树并不是把数据全部放在叶子节点 这样不利于区间查询  </p><h3 id="二叉搜索树："><a href="#二叉搜索树：" class="headerlink" title="二叉搜索树："></a>二叉搜索树：</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102316405.png" alt="image-20240424140323618"></p><p>左小右大 </p><p>二叉树的问题 可能会出现最坏二叉树的情况</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102316171.png" alt="image-20240424140421220"></p><h3 id="红黑树："><a href="#红黑树：" class="headerlink" title="红黑树："></a>红黑树：</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102316354.png" alt="image-20240424140520967"></p><p>解决二叉搜索树的最坏情况 但是由于红黑树的度数为2 所以如果数据量大 那么树的高度就会很高</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引创建的原则</title>
      <link href="/2024/04/26/MySql04-%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99%20%E4%B8%BA%E4%BD%95%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
      <url>/2024/04/26/MySql04-%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99%20%E4%B8%BA%E4%BD%95%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h1 id="索引创建的原则"><a href="#索引创建的原则" class="headerlink" title="索引创建的原则"></a>索引创建的原则</h1><ul><li>针对于数据量较大，且查询比较频繁的表建立索引。   单表超过10万数据(增加用户体验)</li><li>针对于常作为查询条件(where)、排序(orderby)、分组(group by)操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引（就是用字符串的前面几个字）。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li></ul><h1 id="什么时候索引会失效"><a href="#什么时候索引会失效" class="headerlink" title="什么时候索引会失效"></a>什么时候索引会失效</h1><p><strong>name status address 为联合索引</strong></p><h2 id="正例"><a href="#正例" class="headerlink" title="正例"></a>正例</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102318853.png" alt="image-20240424171618229"></p><h3 id="违反最左前缀法则"><a href="#违反最左前缀法则" class="headerlink" title="违反最左前缀法则"></a>违反最左前缀法则</h3><p>反例</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102318866.png" alt="image-20240424171755606"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102318026.png" alt="image-20240424171807925"></p><h3 id="范围查询右边的列，不能使用索引"><a href="#范围查询右边的列，不能使用索引" class="headerlink" title="范围查询右边的列，不能使用索引"></a>范围查询右边的列，不能使用索引</h3><p>反例</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102318773.png" alt="image-20240424171841838"></p><p>status 是一个范围  status右边的列不会生效</p><h3 id="不要在索引列上进行运算操作，索引将失效"><a href="#不要在索引列上进行运算操作，索引将失效" class="headerlink" title="不要在索引列上进行运算操作，索引将失效"></a>不要在索引列上进行运算操作，索引将失效</h3><p>反例</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102318773.png" alt="image-20240424172055613"></p><h3 id="字符串不加单引号，造成索引失效。"><a href="#字符串不加单引号，造成索引失效。" class="headerlink" title="字符串不加单引号，造成索引失效。"></a>字符串不加单引号，造成索引失效。</h3><h2 id><a href="#" class="headerlink" title></a><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102318011.png" alt="image-20240424172132329"></h2><h3 id="以-开头的Like模糊查询，索引失效。"><a href="#以-开头的Like模糊查询，索引失效。" class="headerlink" title="以%开头的Like模糊查询，索引失效。"></a>以%开头的Like模糊查询，索引失效。</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102318971.png" alt="image-20240424172232785"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>违反最左前缀法则</li><li>范围查询右边的列，不能使用索引</li><li>不要在索引列上进行运算操作，索引将失效</li><li>字符串不加单引号，造成索引失效。(类型转换)</li><li>以%开头的Like模糊查询，索引失效。</li></ol><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102318844.png" alt="image-20240424172355280"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是聚簇索引什么是非聚簇索引?</title>
      <link href="/2024/04/26/MySql03-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E3%80%81%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"/>
      <url>/2024/04/26/MySql03-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E3%80%81%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是聚簇索引什么是非聚簇索引"><a href="#什么是聚簇索引什么是非聚簇索引" class="headerlink" title="什么是聚簇索引什么是非聚簇索引?"></a>什么是聚簇索引什么是非聚簇索引?</h1><h2 id="聚集索引-Clustered-Index"><a href="#聚集索引-Clustered-Index" class="headerlink" title="聚集索引(Clustered Index)"></a>聚集索引(Clustered Index)</h2><ul><li>必须有 且只能有一个（主键）</li><li>数据与索引放到一块，B+树的叶子节点保存了整行数据</li></ul><h4 id="聚集索引选取规则"><a href="#聚集索引选取规则" class="headerlink" title="聚集索引选取规则"></a>聚集索引选取规则</h4><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102317574.png" alt="image-20240424141405743"></p><p><strong>如图 在聚集索引的叶子结点存的是整行数据</strong></p><h2 id="二级索引-非聚簇索引"><a href="#二级索引-非聚簇索引" class="headerlink" title="二级索引(非聚簇索引)"></a>二级索引(非聚簇索引)</h2><ul><li>数据与索引分开存储，B+树的叶子节点保存对应的主键</li><li>可以存在多个</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102317286.png" alt="image-20240424144105845"></p><p>二级索引的叶子结点存的数据为主键Id</p><h2 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h2><ul><li>通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表</li></ul><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102317121.png" alt="image-20240424143653014"></p><p>回表查询 指的是通过二级索引 找到主键 然后去聚集索引找到该行 </p><h2 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h2><ul><li>覆盖索引 指的是查询的字段在索引中都能找到 不需要回表</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务ACID特性</title>
      <link href="/2024/04/25/MySql00-%E4%BA%8B%E5%8A%A1ACID/"/>
      <url>/2024/04/25/MySql00-%E4%BA%8B%E5%8A%A1ACID/</url>
      
        <content type="html"><![CDATA[<h1 id="原子性（Automicity）"><a href="#原子性（Automicity）" class="headerlink" title="原子性（Automicity）"></a>原子性（Automicity）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>原子性（Automicity）：事务是一个不可分割的工作单位，事务中的所有操作要么全部完成，要么全部不完成，不会出现部分完成的情况。如果再事务过程中发生错误，会将事务中所有已经执行的操作撤销（回滚Rollback）。</p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>假设有一个银行转账业务，其中需要更新两个账户的余额。如果这两个操作没有被作为一个原子操作来执行，那就可能出现数据不一致的情况。例如，当转出账户的余额已经被减去了一定数额，但由于某些原因（如系统故障、断电等），转入账户的余额没有被增加，此时就会出现数据不一致的情况。</p><p>因此，在这个例子中，将更新两个账户的余额的操作作为一个原子操作，确保这两个操作要么全部执行，要么全部不执行，以保证数据的一致性。如果其中任何一个操作失败，整个事务都应该回滚，保证事务的原子性。</p><h1 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>一致性（Consistency）：事务执行的结果必须使数据库从一个一致性状态变为另一个一致性状态。一致性是指数据的完整性和业务逻辑的正确性。</p><h2 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h2><p>假设一个订单系统，其中一个订单包含了多个商品的信息和总价。为保证系统的一致性，订单的总价应该等于各个商品的价格总和。</p><p>如果再多个事务同时修改订单中的商品价格，就可能导致订单的总价与商品价格总和不一致，从而破坏了数据的一致性。为了解决这个问题，需要对这些修改操作进行协调和同步，使得任何时刻订单的总价都等于各个商品价格总和。</p><p>在这个例子中，可以采用锁机制来保证数据的一致性。在修改订单中商品价格的时候，需要先对订单进行加锁，防止其他事务修改订单中的商品信息，直到本事务完成修改操作并释放锁之后，其他事务才能继续对订单进行操作，从而保证数据的一致性。</p><h1 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>隔离性（Isolation）：多个事务并发执行时，每个事务都应该感觉不到其他事务的存在，各个事务之间应该是隔离的。事务之间的隔离级别会导致不同的并发问题，如脏读、不可重复读和幻读问题。（具体概念例子可以参考博主其他文章《数据库事务四种隔离级别》、《脏读、不可重复读和幻读》）</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设一个银行系统中，用户A和用户B都有各自的账户，并且他们的账户都有1000元的余额。现在用户A向用户B转账500元。这个转账操作会涉及到两个账户的余额的变动，需要使用数据库事务来保证转账操作的正确性。</p><p>在这个转账操作的过程中，如果没有适当的隔离级别，就可能出现一下情况：</p><p>脏读：用户A转账500元之后，但还没提交事务，此时用户B可以读取到账户的变动，但这个变动可能是不可能靠的，因为他随时可能会被回滚。<br>不可重复读：用户B在读取账户的余额之后，用户A又取消了这次转账操作并提交了业务，此时用户B再次读取账户的余额，就会发现和之前读取到的不一样。<br>幻读：假设在转账操作中，还有一个触发器会自动从用户A和用户B的账户中扣除一定的手续费。如果用户A和用户B同时在转账操作中扣除了手续费，就可能出现幻读的情况，即用户A和用户B同时读取到了旧的余额，但在提交事务时却发现总的余额不对。<br>为了避免这些问题，可以用数据库的隔离级别来保证转账操作的正确性。例如，可以使用串行化隔离级别来保证转账操作的原子性、一致性和隔离性，从而避免脏读、不可重复读和幻读的问题。</p><h1 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>持久性（Durability）：一个事务一旦提交，他对数据库中的数据的改变就应该是永久性的。即使出现宕机或者其他异常情况，数据库系统应该能够保证事务的持久性。</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>例如一个用户注册功能的实现。</p><p>当一个用户在应用程序中注册时，这个操作需要保证其持久性。也就是说，一旦用户注册成功，用户的信息应该被持计划的存储在数据库中，以便在用户下一次登录时可以被检索到。</p><p>这个过程需要确保事务的持久性特性，即在用户注册成功后，事务被提交并将数据持久化到数据库中，即使在应用程序或数据库出现故障或重启的情况下，用户数据也能得到保留，不会丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring的单例Bean线程安全吗？</title>
      <link href="/2024/04/25/Spring01-Spring%E7%9A%84%E5%8D%95%E4%BE%8BBean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F/"/>
      <url>/2024/04/25/Spring01-Spring%E7%9A%84%E5%8D%95%E4%BE%8BBean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring的单例Bean线程安全吗？"><a href="#Spring的单例Bean线程安全吗？" class="headerlink" title="Spring的单例Bean线程安全吗？"></a>Spring的单例Bean线程安全吗？</h1><p>首先 Spring中创建一个Bean默认是单例模式的  但是可以通过注解去修改</p><p>实现方式：</p><p>通过注解@Scope去实现</p><p><strong>在bean时，加一个scope &#x3D; “prototype”；如果不写个默认是true，也就是单例的（singleton），写了就是多例的</strong></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202404301422023.png" alt="image-20240423133839585"></p><h2 id="所以Spring的单例Bean线程安全吗？"><a href="#所以Spring的单例Bean线程安全吗？" class="headerlink" title="所以Spring的单例Bean线程安全吗？"></a>所以Spring的单例Bean线程安全吗？</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202404301422657.png" alt="image-20240423134911838"></p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h3><ul><li><strong>count存在线程安全问题 userService不存在线程安全问题</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如 如下图所示 count是一个成员变量 每一个用户都可以去修改count 所以会出现线程安全问题</span><br><span class="line">之所以userService安全 是因为userService是无状态的 无状态指的是当前成员变量是否能被修改 </span><br><span class="line">因为userService的成员变量不能被修改 所以是线程安全的</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul><li>定义能修改的成员变量 存在线程安全问题 </li><li>定义无状态的成员变量 没有线程安全问题</li></ul><p>如果定义的能修改的成员变量 如何解决： 使用多例模式 或者 加锁</p><h2 id="spring的bean为什么是单例的？"><a href="#spring的bean为什么是单例的？" class="headerlink" title="spring的bean为什么是单例的？"></a>spring的bean为什么是单例的？</h2><p>答：为了提高性能。</p><ul><li>由于不会每次都新创建新对象，所以就减少了新生成实例的消耗。因为spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。</li><li>减少JVM垃圾回收，由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。</li><li>可以快速获取到bean，因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。</li><li>缺点就是在并发环境下可能会出现线程安全问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Aop ,Aop的应用场景有哪些?</title>
      <link href="/2024/04/25/Spring02-%E4%BB%80%E4%B9%88%E6%98%AFAop%EF%BC%9FAop%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2024/04/25/Spring02-%E4%BB%80%E4%B9%88%E6%98%AFAop%EF%BC%9FAop%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Aop-Aop的应用场景有哪些"><a href="#什么是Aop-Aop的应用场景有哪些" class="headerlink" title="什么是Aop ,Aop的应用场景有哪些"></a>什么是Aop ,Aop的应用场景有哪些</h1><h2 id="什么是Aop？"><a href="#什么是Aop？" class="headerlink" title="什么是Aop？"></a>什么是Aop？</h2><p>Aop为面向切面编程 Aop是将与业务逻辑无关的代码抽取出来（例如 日志、安全）方便统一的管理和维护 通过Aop 可以将与代码无关的横切关注点定义为切面 再将切面置入业务代码中 降低了模块之间的耦合度</p><h2 id="Aop的应用场景有哪些？"><a href="#Aop的应用场景有哪些？" class="headerlink" title="Aop的应用场景有哪些？"></a>Aop的应用场景有哪些？</h2><ul><li>日志</li><li>登录校验</li><li>缓存</li></ul><h3 id="例子：日志的实现"><a href="#例子：日志的实现" class="headerlink" title="例子：日志的实现"></a>例子：日志的实现</h3><p>1.自定义注解@Log </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.PARAMETER, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span>  <span class="meta">@interface</span> Log &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">模块名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102342653.png" alt="image-20240423140719970"></p><p>2.定义切面类</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102342842.png" alt="image-20240423140750059"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102342885.png" alt="image-20240423142626542"><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343247.png" alt="image-20240423142638137"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343474.png" alt="image-20240423142707611"></p><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343639.png" alt="image-20240427162736931"></p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p><img src="https://gitee.com/antidote-git/photo/raw/master/img/202404271628660.png" alt="image-20240427162816114"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Aop ,Aop的应用场景有哪些?</title>
      <link href="/2024/04/25/Spring03-Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2024/04/25/Spring03-Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring事务失效的场景有哪些"><a href="#Spring事务失效的场景有哪些" class="headerlink" title="Spring事务失效的场景有哪些"></a>Spring事务失效的场景有哪些</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p><strong>事务（Transaction）是访问并可能更新数据库中各项数据项的一个程序执行单元</strong></p><p>事务具有四个特征：<strong>原子性、一致性、隔离性和持久性</strong>。这四个特征通常称为<strong>ACID</strong>。</p><p>原子性（Atomicity）<br>        原子性是指事务是一个不可分割的工作单位，整个事务中的<strong>所有操作要么全部提交成功，要么全部失败回滚</strong>，对于一个事务来说， <strong>不可能只执行其中的一部分操作。</strong></p><p>一致性（Consistency）<br>        一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态。</p><p>​ 也就是说事务<strong>前后数据的完整性必须保持一致</strong>。</p><p>隔离性（Isolation）<br>        隔离性是指一个<strong>事务的执行不能有其他事务的干扰</strong>，事务的内部操作和使用数据对其他的并发事务是隔离的，互不干扰。</p><p>持久性（Durability）<br>        持久性是指一个事务一旦提交，对数据库中数据的改变就是永久性的。此时<strong>即使数据库发生故障，修改的数据也不会丢失</strong>。接下来其他的操作不会对已经提交了的事务产生影响。</p><p><strong>在java的实现方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个方法是事务方法</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//具体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="失效场景有哪些"><a href="#失效场景有哪些" class="headerlink" title="失效场景有哪些"></a>失效场景有哪些</h2><h3 id="1-异常捕获处理"><a href="#1-异常捕获处理" class="headerlink" title="1.异常捕获处理"></a>1.异常捕获处理</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343479.png" alt="image-20240423143944768"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343283.png" alt="image-20240423143952112"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343703.png" alt="image-20240423144009328"></p><h3 id="2-抛出检测异常"><a href="#2-抛出检测异常" class="headerlink" title="2.抛出检测异常"></a>2.抛出检测异常</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343802.png" alt="image-20240423144113742"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343461.png" alt="image-20240423144148256"></p><p><strong>解决方法：</strong></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343235.png" alt="image-20240423144214704"></p><h3 id="3-非public导致事务失效"><a href="#3-非public导致事务失效" class="headerlink" title="3.非public导致事务失效"></a>3.非public导致事务失效</h3><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343314.png" alt="image-20240423144258830"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343597.png" alt="image-20240423144344761"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Aop ,Aop的应用场景有哪些?</title>
      <link href="/2024/04/25/Spring04-Spring%E7%9A%84Bean%E5%91%A8%E6%9C%9F/"/>
      <url>/2024/04/25/Spring04-Spring%E7%9A%84Bean%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring的Bean周期"><a href="#Spring的Bean周期" class="headerlink" title="Spring的Bean周期"></a>Spring的Bean周期</h1><h2 id="导航："><a href="#导航：" class="headerlink" title="导航："></a>导航：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343486.png" alt="image-20240423145322100"></p><h2 id="BeanDefiniTion"><a href="#BeanDefiniTion" class="headerlink" title="BeanDefiniTion"></a>BeanDefiniTion</h2><p>Spring容器在初始化中 会将注解的@Bean的信息封装成一个BeanDefiniTion对象 Spring根据BeanDefiniTion创建Bean对象</p><p>相当于BeanDefiniTion将Spring需要的对象 抓走 然后送给Spring</p><p>话不多说 上代码</p><p>User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, BeanFactoryAware, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User的构造方法执行了.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;张三&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setName方法执行了.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setBeanName方法执行了.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setBeanFactory方法执行了.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setApplicationContext方法执行了........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init方法执行了.................&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterPropertiesSet方法执行了........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory方法执行了...............&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PostProcessor处理器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.lifecycle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;user&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;postProcessBeforeInitialization方法执行了-&gt;user对象初始化方法前开始增强....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;user&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;postProcessAfterInitialization-&gt;user对象初始化方法后开始增强....&quot;</span>);</span><br><span class="line">            <span class="comment">//cglib代理对象</span></span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            <span class="comment">//设置需要增强的类</span></span><br><span class="line">            enhancer.setSuperclass(bean.getClass());</span><br><span class="line">            <span class="comment">//执行回调方法，增强方法</span></span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="comment">//执行目标方法</span></span><br><span class="line">                    <span class="keyword">return</span> method.invoke(method,objects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//创建代理对象</span></span><br><span class="line">            <span class="keyword">return</span> enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343601.png" alt="image-20240423150514078"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405102343653.png" alt="image-20240423151037304"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床的搭建</title>
      <link href="/2024/04/25/%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/04/25/%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="图床的搭建"><a href="#图床的搭建" class="headerlink" title="图床的搭建"></a>图床的搭建</h1><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1V54y197WH/?spm_id_from=333.880.my_history.page.click&vd_source=4d35eecc1a8e0a09fd3c7d45a59d587d">Typora+PicGo+Gitee自动上传图片_哔哩哔哩_bilibili</a></p><p>PICGO+Typora+Gitee搭建图床</p><h2 id="Typoras设置："><a href="#Typoras设置：" class="headerlink" title="Typoras设置："></a>Typoras设置：</h2><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602264.png" alt="image-20240427154359991"></p><p>PicGo的下载路径：<a href="https://molunerfinn.com/PicGo/">PicGo (molunerfinn.com)</a></p><p><strong>路径设置</strong></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602128.png" alt="image-20240427154524081"></p><p>进入PicGo：</p><p>安装这个插件</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602257.png" alt="image-20240427154719573"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602597.png" alt="image-20240427154759736"></p><p>设置</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602685.png" alt="image-20240427154859712"></p><p>owner:</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602861.png" alt="image-20240427155103339"></p><p>redo名：   如果你没有 新建一个就可以了 记得权限选择公开就可以了</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602956.png" alt="image-20240427155200531"></p><p>token：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602082.png" alt="image-20240427155345774"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602430.png" alt="image-20240427155410008"></p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602056.png" alt="image-20240427155504395"></p><p><strong>然后粘贴到token</strong></p><p>最后测试：</p><p><img src="https://qqf-web-tlias.oss-cn-hangzhou.aliyuncs.com/markdown/202405071602943.png" alt="image-20240427155557619"></p><p>成功！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora常用快捷键</title>
      <link href="/2024/03/25/day1-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2024/03/25/day1-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>typora常用快捷键<br>ctrl + &#x2F; 切换编辑语法模式&#x2F;预览模式</p><p>ctrl + 1 <del>6 标题1</del>6 等同于<br>一级标题：#+空格+标题内容<br>二级标题：##+空格+标题内容<br>三级标题：###+空格+标题内容<br>……<br>最多六级标题</p><p>ctrl + B 粗体</p><p>ctrl + I 斜体</p><p>ctrl + T 表格</p><ul><li>无序列表：” <strong>-</strong> “+ 空格 或 “ * ” + 空格</li><li>有序列表：数字+“.”+空格</li><li>生成目录：[TOC]按回车</li><li>选中一整行：ctrl+l</li><li>选中单词：ctrl+d</li><li>选中相同格式的文字：ctrl+e</li><li>跳转到文章开头：ctrl+home</li><li>跳转到文章结尾：ctrl+end</li><li>搜索：ctrl+f</li><li>替换：ctrl+h</li><li>引用：输入&gt;之后输入空格</li><li>代码块：ctrl+shfit+k</li><li>加粗：ctrl+b</li><li>倾斜：ctrl+i</li><li>下划线：ctrl+u</li><li>删除线：alt+shift+5 或 ～～内容～～</li><li>分割线：- - - 或***</li><li>插入链接：ctrl+k</li><li>数学公式：$$ + enter</li><li>表情: :+单词+:</li><li><strong>常用表情地址：</strong><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">https://www.webfx.com/tools/emoji-cheat-sheet/</a></li><li>目录：[toc] + enter</li><li>插入图片：直接拖动到指定位置即可或者ctrl+shift+i</li></ul><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><p>关于我为什么要开始写编程日记，之前我对日记是不屑的，我总是觉得没什么好记的。最主要是觉得浪费时间。</p><p>现在开始写是因为我的想法发生了一些改变：</p><p>目前状况，每天学习3~5个小时，我坚持了大概有一周，一周之后我就发现，我忘记了之前学的 </p><p>什么框架啊 理论啊 七七八八的 还有nodejs的安装啊 环境的搭建啊  这些东西很容易忘</p><p>比如之前学的springboot框架 还有一些注解 总是容易漏</p><p>所以 我决定尝试写日记 去记录一天学的东西 </p><p>其实我觉得 写日记 最重要的是 方便查 </p><p>说实话 我觉得csdn有时候 有点不好找 不如找自己写的东西</p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>安装好NodeJS以后如果不进行相关配置，会存在如下问题：</p><p>第一个：执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到<strong>C:\Users\用户名\AppData\Roaming\npm</strong> 路径中</p><p>设置淘宝镜像命令的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>1<br>清除淘宝镜像命令即重新设置原来的即可，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><h4 id="直接编辑npm的配置文件"><a href="#直接编辑npm的配置文件" class="headerlink" title="直接编辑npm的配置文件"></a>直接编辑npm的配置文件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm config edit</span><br><span class="line"></span><br><span class="line">npm cache clean --force  //清除缓存</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="yarn的常用命令："><a href="#yarn的常用命令：" class="headerlink" title="yarn的常用命令："></a>yarn的常用命令：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yarn -v  // 查看yarn 版本</span><br><span class="line"></span><br><span class="line">yarn config list  // 查看yarn配置</span><br><span class="line"></span><br><span class="line">yarn config get registry   // 查看当前yarn源</span><br><span class="line"></span><br><span class="line">// 修改yarn源（此处为淘宝的源）</span><br><span class="line">yarn config set registry https://registry.npm.taobao.org  </span><br><span class="line"></span><br><span class="line">// yarn安装依赖</span><br><span class="line">      </span><br><span class="line">yarn global bin // 会出现 yarn 安装的全局路径</span><br><span class="line">yarn add 包名          // 局部安装</span><br><span class="line"></span><br><span class="line">yarn global add 包名   // 全局安装</span><br><span class="line"></span><br><span class="line">// yarn 卸载依赖</span><br><span class="line">yarn remove 包名         // 局部卸载</span><br><span class="line">yarn global remove 包名  // 全局卸载（如果安装时安到了全局，那么卸载就要对应卸载全局的）</span><br><span class="line">// yarn 查看全局安装过的包</span><br></pre></td></tr></table></figure><h2 id="npm-ERR-errno-4048"><a href="#npm-ERR-errno-4048" class="headerlink" title="npm ERR! errno -4048"></a>npm ERR! errno -4048</h2><p>npm ERR! Error: EPERM: operation not permitted, mkdir ‘D:\software\nodejs\node_cache_cacache’</p><p><a href="https://blog.csdn.net/qq_50790981/article/details/124991911?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-124991911-blog-79818011.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-124991911-blog-79818011.235%5Ev43%5Epc_blog_bottom_relevance_base1">Error: EPERM: operation not permitted, mkdir ‘D:\software\nodejs\node_cache_cacach两种解决办法-CSDN博客</a></p><h2 id="idea新快捷键"><a href="#idea新快捷键" class="headerlink" title="idea新快捷键"></a>idea新快捷键</h2><p>alt+f7:查看当前变量在所有文件中的使用</p><p>ctrl+e:方便打开最近使用文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计划书：伙伴匹配系统</title>
      <link href="/2024/03/25/%E8%AE%A1%E5%88%92%E4%B9%A601%EF%BC%9A%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/03/25/%E8%AE%A1%E5%88%92%E4%B9%A601%EF%BC%9A%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="计划书：伙伴匹配系统"><a href="#计划书：伙伴匹配系统" class="headerlink" title="计划书：伙伴匹配系统"></a>计划书：伙伴匹配系统</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a><strong>背景：</strong></h2><p>2024.04.07</p><p>刚刚做清明回来 有两三天这样么敲代码了 昨天回来太累了 就没状态敲代码  </p><p>现在打算复习一下上次学的 上次学到<strong>redis</strong> 打算复习一下redis （其实本来就没学多少）</p><h2 id="具体计划："><a href="#具体计划：" class="headerlink" title="具体计划："></a>具体计划：</h2><p>33~36</p><ul><li>33.redis入门</li><li>34.缓存开发和注意事项</li><li>35.缓存预热设计与实现</li><li>36.定时任务介绍和实现</li><li>37.锁、分布式锁介绍</li></ul><h2 id="个人总结："><a href="#个人总结：" class="headerlink" title="个人总结："></a>个人总结：</h2><p>几天先做这么多事吧  刚刚回来不想给自己太多压力 先调整状态</p>]]></content>
      
      
      <categories>
          
          <category> 计划书 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
