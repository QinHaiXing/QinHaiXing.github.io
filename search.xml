<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计划书08</title>
      <link href="/2024/04/27/%E8%AE%A1%E5%88%92%E4%B9%A608-%E5%A4%8D%E4%B9%A0%E5%92%8C%E6%8E%A8%E8%BF%9B/"/>
      <url>/2024/04/27/%E8%AE%A1%E5%88%92%E4%B9%A608-%E5%A4%8D%E4%B9%A0%E5%92%8C%E6%8E%A8%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<p>计划书08-复习和推进</p><p>这几天也想写计划书 但是每次想写的时候都是很晚了 </p><p>有的时候有想法 但是又懒得打开 主要是之前没有弄图床 而且又一直在弄域名和个人博客 所以主线就落下了几天</p><p>今天打算先复习 然后写一下这几天个人博客搭建的过程 图床的过程</p><p>具体计划：</p><ol><li>完成“全面认识全过程人民民主”形策论文</li><li>写一篇图床的搭建过程</li><li>复习上次写的Spring八股和MySQL八股</li><li>推进主线 学习伙伴匹配系统 55~57</li></ol><p>加油加油🚀🚀🚀</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>事务ACID特性</title>
      <link href="/2024/04/25/00-%E4%BA%8B%E5%8A%A1ACID/"/>
      <url>/2024/04/25/00-%E4%BA%8B%E5%8A%A1ACID/</url>
      
        <content type="html"><![CDATA[<h1 id="原子性（Automicity）"><a href="#原子性（Automicity）" class="headerlink" title="原子性（Automicity）"></a>原子性（Automicity）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>原子性（Automicity）：事务是一个不可分割的工作单位，事务中的所有操作要么全部完成，要么全部不完成，不会出现部分完成的情况。如果再事务过程中发生错误，会将事务中所有已经执行的操作撤销（回滚Rollback）。</p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>假设有一个银行转账业务，其中需要更新两个账户的余额。如果这两个操作没有被作为一个原子操作来执行，那就可能出现数据不一致的情况。例如，当转出账户的余额已经被减去了一定数额，但由于某些原因（如系统故障、断电等），转入账户的余额没有被增加，此时就会出现数据不一致的情况。</p><p>因此，在这个例子中，将更新两个账户的余额的操作作为一个原子操作，确保这两个操作要么全部执行，要么全部不执行，以保证数据的一致性。如果其中任何一个操作失败，整个事务都应该回滚，保证事务的原子性。</p><h1 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>一致性（Consistency）：事务执行的结果必须使数据库从一个一致性状态变为另一个一致性状态。一致性是指数据的完整性和业务逻辑的正确性。</p><h2 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h2><p>假设一个订单系统，其中一个订单包含了多个商品的信息和总价。为保证系统的一致性，订单的总价应该等于各个商品的价格总和。</p><p>如果再多个事务同时修改订单中的商品价格，就可能导致订单的总价与商品价格总和不一致，从而破坏了数据的一致性。为了解决这个问题，需要对这些修改操作进行协调和同步，使得任何时刻订单的总价都等于各个商品价格总和。</p><p>在这个例子中，可以采用锁机制来保证数据的一致性。在修改订单中商品价格的时候，需要先对订单进行加锁，防止其他事务修改订单中的商品信息，直到本事务完成修改操作并释放锁之后，其他事务才能继续对订单进行操作，从而保证数据的一致性。</p><h1 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>隔离性（Isolation）：多个事务并发执行时，每个事务都应该感觉不到其他事务的存在，各个事务之间应该是隔离的。事务之间的隔离级别会导致不同的并发问题，如脏读、不可重复读和幻读问题。（具体概念例子可以参考博主其他文章《数据库事务四种隔离级别》、《脏读、不可重复读和幻读》）</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设一个银行系统中，用户A和用户B都有各自的账户，并且他们的账户都有1000元的余额。现在用户A向用户B转账500元。这个转账操作会涉及到两个账户的余额的变动，需要使用数据库事务来保证转账操作的正确性。</p><p>在这个转账操作的过程中，如果没有适当的隔离级别，就可能出现一下情况：</p><p>脏读：用户A转账500元之后，但还没提交事务，此时用户B可以读取到账户的变动，但这个变动可能是不可能靠的，因为他随时可能会被回滚。<br>不可重复读：用户B在读取账户的余额之后，用户A又取消了这次转账操作并提交了业务，此时用户B再次读取账户的余额，就会发现和之前读取到的不一样。<br>幻读：假设在转账操作中，还有一个触发器会自动从用户A和用户B的账户中扣除一定的手续费。如果用户A和用户B同时在转账操作中扣除了手续费，就可能出现幻读的情况，即用户A和用户B同时读取到了旧的余额，但在提交事务时却发现总的余额不对。<br>为了避免这些问题，可以用数据库的隔离级别来保证转账操作的正确性。例如，可以使用串行化隔离级别来保证转账操作的原子性、一致性和隔离性，从而避免脏读、不可重复读和幻读的问题。</p><h1 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>持久性（Durability）：一个事务一旦提交，他对数据库中的数据的改变就应该是永久性的。即使出现宕机或者其他异常情况，数据库系统应该能够保证事务的持久性。</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>例如一个用户注册功能的实现。</p><p>当一个用户在应用程序中注册时，这个操作需要保证其持久性。也就是说，一旦用户注册成功，用户的信息应该被持计划的存储在数据库中，以便在用户下一次登录时可以被检索到。</p><p>这个过程需要确保事务的持久性特性，即在用户注册成功后，事务被提交并将数据持久化到数据库中，即使在应用程序或数据库出现故障或重启的情况下，用户数据也能得到保留，不会丢失。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>typora常用快捷键</title>
      <link href="/2024/03/25/day1-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2024/03/25/day1-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>typora常用快捷键<br>ctrl + &#x2F; 切换编辑语法模式&#x2F;预览模式</p><p>ctrl + 1 <del>6 标题1</del>6 等同于<br>一级标题：#+空格+标题内容<br>二级标题：##+空格+标题内容<br>三级标题：###+空格+标题内容<br>……<br>最多六级标题</p><p>ctrl + B 粗体</p><p>ctrl + I 斜体</p><p>ctrl + T 表格</p><ul><li>无序列表：” <strong>-</strong> “+ 空格 或 “ * ” + 空格</li><li>有序列表：数字+“.”+空格</li><li>生成目录：[TOC]按回车</li><li>选中一整行：ctrl+l</li><li>选中单词：ctrl+d</li><li>选中相同格式的文字：ctrl+e</li><li>跳转到文章开头：ctrl+home</li><li>跳转到文章结尾：ctrl+end</li><li>搜索：ctrl+f</li><li>替换：ctrl+h</li><li>引用：输入&gt;之后输入空格</li><li>代码块：ctrl+shfit+k</li><li>加粗：ctrl+b</li><li>倾斜：ctrl+i</li><li>下划线：ctrl+u</li><li>删除线：alt+shift+5 或 ～～内容～～</li><li>分割线：- - - 或***</li><li>插入链接：ctrl+k</li><li>数学公式：$$ + enter</li><li>表情: :+单词+:</li><li><strong>常用表情地址：</strong><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">https://www.webfx.com/tools/emoji-cheat-sheet/</a></li><li>目录：[toc] + enter</li><li>插入图片：直接拖动到指定位置即可或者ctrl+shift+i</li></ul><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><p>关于我为什么要开始写编程日记，之前我对日记是不屑的，我总是觉得没什么好记的。最主要是觉得浪费时间。</p><p>现在开始写是因为我的想法发生了一些改变：</p><p>目前状况，每天学习3~5个小时，我坚持了大概有一周，一周之后我就发现，我忘记了之前学的 </p><p>什么框架啊 理论啊 七七八八的 还有nodejs的安装啊 环境的搭建啊  这些东西很容易忘</p><p>比如之前学的springboot框架 还有一些注解 总是容易漏</p><p>所以 我决定尝试写日记 去记录一天学的东西 </p><p>其实我觉得 写日记 最重要的是 方便查 </p><p>说实话 我觉得csdn有时候 有点不好找 不如找自己写的东西</p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>安装好NodeJS以后如果不进行相关配置，会存在如下问题：</p><p>第一个：执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到<strong>C:\Users\用户名\AppData\Roaming\npm</strong> 路径中</p><p>设置淘宝镜像命令的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>1<br>清除淘宝镜像命令即重新设置原来的即可，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><h4 id="直接编辑npm的配置文件"><a href="#直接编辑npm的配置文件" class="headerlink" title="直接编辑npm的配置文件"></a>直接编辑npm的配置文件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm config edit</span><br><span class="line"></span><br><span class="line">npm cache clean --force  //清除缓存</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="yarn的常用命令："><a href="#yarn的常用命令：" class="headerlink" title="yarn的常用命令："></a>yarn的常用命令：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yarn -v  // 查看yarn 版本</span><br><span class="line"></span><br><span class="line">yarn config list  // 查看yarn配置</span><br><span class="line"></span><br><span class="line">yarn config get registry   // 查看当前yarn源</span><br><span class="line"></span><br><span class="line">// 修改yarn源（此处为淘宝的源）</span><br><span class="line">yarn config set registry https://registry.npm.taobao.org  </span><br><span class="line"></span><br><span class="line">// yarn安装依赖</span><br><span class="line">      </span><br><span class="line">yarn global bin // 会出现 yarn 安装的全局路径</span><br><span class="line">yarn add 包名          // 局部安装</span><br><span class="line"></span><br><span class="line">yarn global add 包名   // 全局安装</span><br><span class="line"></span><br><span class="line">// yarn 卸载依赖</span><br><span class="line">yarn remove 包名         // 局部卸载</span><br><span class="line">yarn global remove 包名  // 全局卸载（如果安装时安到了全局，那么卸载就要对应卸载全局的）</span><br><span class="line">// yarn 查看全局安装过的包</span><br></pre></td></tr></table></figure><h2 id="npm-ERR-errno-4048"><a href="#npm-ERR-errno-4048" class="headerlink" title="npm ERR! errno -4048"></a>npm ERR! errno -4048</h2><p>npm ERR! Error: EPERM: operation not permitted, mkdir ‘D:\software\nodejs\node_cache_cacache’</p><p><a href="https://blog.csdn.net/qq_50790981/article/details/124991911?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-124991911-blog-79818011.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-124991911-blog-79818011.235%5Ev43%5Epc_blog_bottom_relevance_base1">Error: EPERM: operation not permitted, mkdir ‘D:\software\nodejs\node_cache_cacach两种解决办法-CSDN博客</a></p><h2 id="idea新快捷键"><a href="#idea新快捷键" class="headerlink" title="idea新快捷键"></a>idea新快捷键</h2><p>alt+f7:查看当前变量在所有文件中的使用</p><p>ctrl+e:方便打开最近使用文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计划书：伙伴匹配系统</title>
      <link href="/2024/03/25/%E8%AE%A1%E5%88%92%E4%B9%A601%EF%BC%9A%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/03/25/%E8%AE%A1%E5%88%92%E4%B9%A601%EF%BC%9A%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="计划书：伙伴匹配系统"><a href="#计划书：伙伴匹配系统" class="headerlink" title="计划书：伙伴匹配系统"></a>计划书：伙伴匹配系统</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a><strong>背景：</strong></h2><p>2024.04.07</p><p>刚刚做清明回来 有两三天这样么敲代码了 昨天回来太累了 就没状态敲代码  </p><p>现在打算复习一下上次学的 上次学到<strong>redis</strong> 打算复习一下redis （其实本来就没学多少）</p><h2 id="具体计划："><a href="#具体计划：" class="headerlink" title="具体计划："></a>具体计划：</h2><p>33~36</p><ul><li>33.redis入门</li><li>34.缓存开发和注意事项</li><li>35.缓存预热设计与实现</li><li>36.定时任务介绍和实现</li><li>37.锁、分布式锁介绍</li></ul><h2 id="个人总结："><a href="#个人总结：" class="headerlink" title="个人总结："></a>个人总结：</h2><p>几天先做这么多事吧  刚刚回来不想给自己太多压力 先调整状态</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring的单例Bean线程安全吗?</title>
      <link href="/2024/03/25/1-Spring%E7%9A%84%E5%8D%95%E4%BE%8BBean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F/"/>
      <url>/2024/03/25/1-Spring%E7%9A%84%E5%8D%95%E4%BE%8BBean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring的单例Bean线程安全吗？"><a href="#Spring的单例Bean线程安全吗？" class="headerlink" title="Spring的单例Bean线程安全吗？"></a>Spring的单例Bean线程安全吗？</h1><p>首先 Spring中创建一个Bean默认是单例模式的  但是可以通过注解去修改</p><p>实现方式：</p><p>通过注解@Scope去实现</p><p><strong>在bean时，加一个scope &#x3D; “prototype”；如果不写个默认是true，也就是单例的（singleton），写了就是多例的</strong></p><p><img src="C:\Users\Atdote\AppData\Roaming\Typora\typora-user-images\image-20240423133839585.png" alt="image-20240423133839585"></p><h2 id="所以Spring的单例Bean线程安全吗？"><a href="#所以Spring的单例Bean线程安全吗？" class="headerlink" title="所以Spring的单例Bean线程安全吗？"></a>所以Spring的单例Bean线程安全吗？</h2><p><img src="C:\Users\Atdote\AppData\Roaming\Typora\typora-user-images\image-20240423134911838.png" alt="image-20240423134911838"></p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h3><ul><li><strong>count存在线程安全问题 userService不存在线程安全问题</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如 如下图所示 count是一个成员变量 每一个用户都可以去修改count 所以会出现线程安全问题</span><br><span class="line">之所以userService安全 是因为userService是无状态的 无状态指的是当前成员变量是否能被修改 </span><br><span class="line">因为userService的成员变量不能被修改 所以是线程安全的</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul><li>定义能修改的成员变量 存在线程安全问题 </li><li>定义无状态的成员变量 没有线程安全问题</li></ul><p>如果定义的能修改的成员变量 如何解决： 使用多例模式 或者 加锁</p><h2 id="spring的bean为什么是单例的？"><a href="#spring的bean为什么是单例的？" class="headerlink" title="spring的bean为什么是单例的？"></a>spring的bean为什么是单例的？</h2><p>答：为了提高性能。</p><ul><li>由于不会每次都新创建新对象，所以就减少了新生成实例的消耗。因为spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。</li><li>减少JVM垃圾回收，由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。</li><li>可以快速获取到bean，因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。</li><li>缺点就是在并发环境下可能会出现线程安全问题</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
